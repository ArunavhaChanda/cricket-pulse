<!-- templates/match.html -->
{% extends "base.html" %}

{% block title %}{{ match.team1.short_name }} vs {{ match.team2.short_name }} - Cricket Pulse{% endblock %}
{% block subtitle %}Live Cricket Match Simulation{% endblock %}

{% block extra_css %}
<style>
    /* Add your custom CSS here */
    
    /* Event Animation System */
    .event-animation {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        z-index: 9999;
        pointer-events: none;
        opacity: 0;
        transition: all 0.5s ease;
    }
    
    .event-animation.animate {
        opacity: 1;
        transform: translate(-50%, -50%) scale(1);
    }
    
    .event-animation.fade-out {
        opacity: 0;
        transform: translate(-50%, -50%) scale(0.8);
    }
    
    .animation-content {
        text-align: center;
        padding: 30px 50px;
        border-radius: 20px;
        box-shadow: 0 20px 40px rgba(0,0,0,0.5);
        backdrop-filter: blur(10px);
        border: 3px solid;
        animation: pulseGlow 2s ease-in-out;
    }
    
    .animation-title {
        font-size: 4rem;
        font-weight: bold;
        margin-bottom: 10px;
        text-shadow: 0 0 20px currentColor;
        animation: textShake 0.5s ease-in-out 0.5s;
    }
    
    .animation-subtitle {
        font-size: 1.5rem;
        opacity: 0.9;
        animation: fadeInUp 0.8s ease-out 0.3s both;
    }
    
    /* Six Animation - Golden and Glowing */
    .six-animation .animation-content {
        background: linear-gradient(135deg, rgba(255,215,0,0.9), rgba(255,165,0,0.9));
        border-color: #ffd700;
        color: #8b4513;
    }
    
    .six-animation .animation-title {
        animation: sixBounce 1s ease-out 0.5s;
    }
    
    /* Four Animation - Blue and Electric */
    .four-animation .animation-content {
        background: linear-gradient(135deg, rgba(30,144,255,0.9), rgba(0,191,255,0.9));
        border-color: #1e90ff;
        color: #fff;
    }
    
    .four-animation .animation-title {
        animation: fourSlide 1s ease-out 0.5s;
    }
    
    /* Wicket Animation - Red and Fiery */
    .wicket-animation .animation-content {
        background: linear-gradient(135deg, rgba(220,20,60,0.9), rgba(255,69,0,0.9));
        border-color: #dc143c;
        color: #fff;
    }
    
    .wicket-animation .animation-title {
        animation: wicketExplode 1s ease-out 0.5s;
    }
    
    /* Keyframe Animations */
    @keyframes pulseGlow {
        0%, 100% { box-shadow: 0 20px 40px rgba(0,0,0,0.5); }
        50% { box-shadow: 0 20px 40px rgba(255,255,255,0.3), 0 0 60px currentColor; }
    }
    
    @keyframes textShake {
        0%, 100% { transform: translateX(0); }
        25% { transform: translateX(-5px); }
        75% { transform: translateX(5px); }
    }
    
    @keyframes fadeInUp {
        from { opacity: 0; transform: translateY(20px); }
        to { opacity: 1; transform: translateY(0); }
    }
    
    @keyframes sixBounce {
        0% { transform: scale(1); }
        50% { transform: scale(1.2) rotate(5deg); }
        100% { transform: scale(1) rotate(0deg); }
    }
    
    @keyframes fourSlide {
        0% { transform: translateX(-50px); opacity: 0; }
        100% { transform: translateX(0); opacity: 1; }
    }
    
    @keyframes wicketExplode {
        0% { transform: scale(1) rotate(0deg); }
        50% { transform: scale(1.3) rotate(180deg); }
        100% { transform: scale(1) rotate(360deg); }
    }
</style>
{% endblock %}

{% block extra_js %}
<script>
// Stats Classes
class BattingScore {
    constructor(playerName) {
        this.playerName = playerName;
        this.runsScored = 0;
        this.ballsFaced = 0;
        this.dots = 0;
        this.notOut = true;
        this.sixesHit = 0;
        this.foursHit = 0;
        this.extras = 0; // Track extras received by this batsman
        this.methodOfDismissal = "";
        this.bowledByPlayerName = "";
        this.caughtByPlayerName = "";
        this.stumpedByPlayerName = "";
    }
    
    dot() {
        this.ballsFaced += 1;
        this.dots += 1;
    }
    
    single() {
        this.runsScored += 1;
        this.ballsFaced += 1;
    }
    
    twoRuns() {
        this.runsScored += 2;
        this.ballsFaced += 1;
    }
    
    threeRuns() {
        this.runsScored += 3;
        this.ballsFaced += 1;
    }
    
    fourRuns() {
        this.runsScored += 4;
        this.ballsFaced += 1;
        this.foursHit += 1;
    }
    
    sixRuns() {
        this.runsScored += 6;
        this.ballsFaced += 1;
        this.sixesHit += 1;
    }
    
    // Handle extras (no balls, wide balls) - doesn't count as balls faced
    addExtras(extraRuns) {
        this.extras += extraRuns;
    }
    
    out(method, bowler, fielder = null) {
        this.ballsFaced += 1;
        this.dots += 1;
        this.notOut = false;
        this.methodOfDismissal = method;
        
        if (method === "caught" && fielder) {
            this.caughtByPlayerName = fielder.name;
        }
        if (method === "stumped" && fielder) {
            this.stumpedByPlayerName = fielder.name;
        }
        if (bowler) {
            this.bowledByPlayerName = bowler.name;
        }
    }
    
    getStrikeRate() {
        if (this.ballsFaced === 0) return 0;
        return (this.runsScored * 100) / this.ballsFaced;
    }
    
    getScorecardRow() {
        const playerNameSegment = this.playerName + (this.notOut ? " *" : "");
        
        let dismissalDetailSegment = "";
        if (this.methodOfDismissal === "caught") {
            dismissalDetailSegment = "c. " + this.caughtByPlayerName + " b. " + this.bowledByPlayerName;
        } else if (this.methodOfDismissal === "stumped") {
            dismissalDetailSegment = "st. " + this.stumpedByPlayerName + " b. " + this.bowledByPlayerName;
        } else if (this.methodOfDismissal === "lbw") {
            dismissalDetailSegment = "lbw b. " + this.bowledByPlayerName;
        }
        
        const bowledSegment = this.notOut ? "" : "b. " + this.bowledByPlayerName;
        const scoreSegment = `${this.runsScored}(${this.ballsFaced})`;
        const strikeRateSegment = this.getStrikeRate().toFixed(2);
        
        return {
            playerName: playerNameSegment,
            dismissal: dismissalDetailSegment,
            bowled: bowledSegment,
            score: scoreSegment,
            strikeRate: strikeRateSegment,
            sixes: this.sixesHit,
            fours: this.foursHit,
            dots: this.dots,
            extras: this.extras
        };
    }
    
    getShortScore(onStrike = false) {
        return `${this.playerName}${onStrike ? " *" : ""} ${this.runsScored}(${this.ballsFaced})`;
    }
}

class BowlingFigures {
    constructor(playerName) {
        this.playerName = playerName;
        this.deliveries = 0;
        this.dotBalls = 0;
        this.runsConceded = 0;
        this.wicketsTaken = 0;
        this.economyRate = 0.0;
    }
    
    dot() {
        this.deliveries += 1;
        this.dotBalls += 1;
    }
    
    noBall() {
        // No ball doesn't count as a delivery but gives a run
        this.runsConceded += 1;
    }
    
    wideBall() {
        this.runsConceded += 1;
    }
    
    single() {
        this.runsConceded += 1;
        this.deliveries += 1;
    }
    
    twoRuns() {
        this.runsConceded += 2;
        this.deliveries += 1;
    }
    
    threeRuns() {
        this.runsConceded += 3;
        this.deliveries += 1;
    }
    
    fourRuns() {
        this.runsConceded += 4;
        this.deliveries += 1;
    }
    
    sixRuns() {
        this.runsConceded += 6;
        this.deliveries += 1;
    }
    
    wicket() {
        this.deliveries += 1;
        this.wicketsTaken += 1;
        this.dotBalls += 1;
    }
    
    getFormattedOvers() {
        const overs = Math.floor(this.deliveries / 6);
        const balls = this.deliveries % 6;
        return balls === 0 ? overs.toString() : `${overs}.${balls}`;
    }
    
    getEconomyRate() {
        if (this.deliveries === 0) return 0;
        return (this.runsConceded / this.deliveries) * 6.0;
    }
    
    getFigures() {
        const overs = this.getFormattedOvers();
        const dots = this.dotBalls;
        const runs = this.runsConceded;
        const wickets = this.wicketsTaken;
        const economy = this.getEconomyRate().toFixed(2);
        
        return `${overs}-${dots}-${runs}-${wickets} ${economy}`;
    }
    
    getScorecardRow() {
        return {
            playerName: this.playerName,
            figures: this.getFigures(),
            overs: this.getFormattedOvers(),
            dots: this.dotBalls,
            runs: this.runsConceded,
            wickets: this.wicketsTaken,
            economy: this.getEconomyRate().toFixed(2)
        };
    }
    
    getShortScore() {
        return `${this.playerName} ${this.wicketsTaken}/${this.runsConceded}`;
    }
}

class ScorecardManager {
    constructor() {
        this.innings = {
            1: { batting: {}, bowling: {} },
            2: { batting: {}, bowling: {} }
        };
    }
    
    initializeInnings(inningsNumber, battingTeam, bowlingTeam) {
        // Initialize batting stats for all players
        battingTeam.players.forEach(player => {
            this.innings[inningsNumber].batting[player.id] = new BattingScore(player.name);
        });
        
        // Initialize bowling stats for all players
        bowlingTeam.players.forEach(player => {
            this.innings[inningsNumber].bowling[player.id] = new BowlingFigures(player.name);
        });
    }
    
    getBattingScore(inningsNumber, playerId) {
        return this.innings[inningsNumber].batting[playerId];
    }
    
    getBowlingFigures(inningsNumber, playerId) {
        return this.innings[inningsNumber].bowling[playerId];
    }
    
    updateBattingStats(inningsNumber, playerId, runs, isWicket, dismissalType, bowler, fielder, extras = 0) {
        const battingScore = this.getBattingScore(inningsNumber, playerId);
        if (!battingScore) return;
        
        // Handle extras first (no balls, wide balls)
        if (extras > 0) {
            battingScore.addExtras(extras);
            // Don't increment ballsFaced for extras
            return;
        }
        
        if (isWicket) {
            battingScore.out(dismissalType, bowler, fielder);
        } else if (runs === 0) {
            battingScore.dot();
        } else if (runs === 1) {
            battingScore.single();
        } else if (runs === 2) {
            battingScore.twoRuns();
        } else if (runs === 3) {
            battingScore.threeRuns();
        } else if (runs === 4) {
            battingScore.fourRuns();
        } else if (runs === 6) {
            battingScore.sixRuns();
        }
    }
    
    updateBowlingStats(inningsNumber, playerId, runs, isWicket, extras) {
        const bowlingFigures = this.getBowlingFigures(inningsNumber, playerId);
        if (!bowlingFigures) return;
        
        if (extras === 'wide') {
            bowlingFigures.wideBall();
        } else if (extras === 'noball') {
            bowlingFigures.noBall();
        } else {
            if (isWicket) {
                bowlingFigures.wicket();
            } else if (runs === 0) {
                bowlingFigures.dot();
            } else if (runs === 1) {
                bowlingFigures.single();
            } else if (runs === 2) {
                bowlingFigures.twoRuns();
            } else if (runs === 3) {
                bowlingFigures.threeRuns();
            } else if (runs === 4) {
                bowlingFigures.fourRuns();
            } else if (runs === 6) {
                bowlingFigures.sixRuns();
            }
        }
    }
    
    getInningsScorecard(inningsNumber) {
        return {
            batting: Object.values(this.innings[inningsNumber].batting),
            bowling: Object.values(this.innings[inningsNumber].bowling)
        };
    }
    
    getFullMatchScorecard() {
        return {
            firstInnings: this.getInningsScorecard(1),
            secondInnings: this.getInningsScorecard(2)
        };
    }
}

let matchState = {
    currentInnings: 1, // 1 for first innings, 2 for second innings
    battingTeam: null,
    firstInningsBattingOrderPlayers: [], // Track first innings batting order separately
    secondInningsBattingOrderPlayers: [], // Track second innings batting order separately
    battingOrderPlayers: null, // Current innings batting order (will point to appropriate array)
    firstInningsBattingTeam: null, // Store first innings batting team
    bowlingTeam: null,
    striker: null,
    nonStriker: null,
    currentBowler: null,
    fielder: null,
    wicketkeeper: null,
    isAutoSimulating: false,
    autoInterval: null,
    firstInningsScore: 0, // Store first innings total
    target: 0, // Target for second innings
    secondInningsBattingTeam: null, // Team batting in second innings
    secondInningsBowlingTeam: null, // Team bowling in second innings
    matchResult: null, // Store final match result
    scorecardManager: new ScorecardManager() // New stats tracking system
};

// Initialize match interface
document.addEventListener('DOMContentLoaded', function() {
    // Set initial display based on match status
    initializeMatchDisplay();
    
    // Join match room for real-time updates
    socket.emit('join_match', { match_id: MATCH_DATA.match_id });
    
    // Load current match state
    loadMatchState();
    
    // Set up WebSocket event listeners
    setupWebSocketListeners();
});

function initializeMatchDisplay() {
    // Show appropriate sections based on match status
    if (MATCH_DATA.status === 'setup') {
        document.getElementById('toss-section').style.display = 'block';
    }
}

function setupWebSocketListeners() {
    socket.on('toss_result', function(data) {
        if (data.match_id === MATCH_DATA.match_id) {
            handleTossResult(data);
        }
    });
    
    socket.on('toss_decision', function(data) {
        if (data.match_id === MATCH_DATA.match_id) {
            handleTossDecision(data);
        }
    });
    
    socket.on('match_started', function(data) {
        if (data.match_id === MATCH_DATA.match_id) {
            handleMatchStart(data);
        }
    });
    
    socket.on('delivery_update', function(data) {
        if (data.match_id === MATCH_DATA.match_id) {
            console.log('WebSocket delivery_update received:', data);
            
            // Process the server data properly
            if (data.delivery_result) {
                const processedData = {
                    type: processDeliveryType(data.delivery_result.runs_scored, data.delivery_result.is_wicket, data.delivery_result.extras) || 'unknown',
                    runs: data.delivery_result.runs_scored || 0,
                    extras: data.delivery_result.extras || 0,
                    isWicket: data.delivery_result.is_wicket || false,
                    dismissal_type: data.delivery_result.dismissal_type || null,
                    ballNumber: (matchState.currentBalls || 0) + 1,
                    overNumber: Math.floor((matchState.currentBalls || 0) / 6) + 1
                };
                
                console.log('Processed WebSocket data:', processedData);
                handleDeliveryUpdate({
                    match_id: data.match_id,
                    ...processedData
                });
            } else {
                console.error('No delivery_result in WebSocket data:', data);
            }
        }
    });

    socket.on('innings_complete', function(data) {
        if (data.match_id === MATCH_DATA.match_id) {
            handleInningsComplete(data);
        }
    });
    
    socket.on('match_complete', function(data) {
        if (data.match_id === MATCH_DATA.match_id) {
            handleMatchComplete(data);
        }
    });
}

function loadMatchState() {
    // This would fetch the current match state from the server
    // For now, we'll use the initial state from the template
    updateMatchDisplay();
}

function conductToss() {
    const selectedRadio = document.querySelector('input[name="toss-call"]:checked');
    let call; // Declare call variable outside the if/else blocks
    
    if (selectedRadio) {
        call = selectedRadio.value;
    } else {
        console.error('No toss call selected; heads given as default');
        call = "heads";
    }
    
    fetch(`/api/matches/${MATCH_DATA.match_id}/toss`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify({
            calling_team_id: MATCH_DATA.team1.id,
            call: call
        })
    })
    .then(response => response.json())
    .then(data => {
        if (data.error) {
            showNotification(data.error, 'error');
        } else {
            // Toss result will be handled by WebSocket
            showNotification('Toss conducted!', 'success');
        }
    })
    .catch(error => {
        showNotification('Error conducting toss', 'error');
        console.error('Error:', error);
    });
}

function handleTossResult(data) {
    // Hide toss section
    document.getElementById('toss-section').style.display = 'none';
    
    // Show toss decision section
    const tossDecisionSection = document.getElementById('toss-decision-section');
    const resultText = document.getElementById('toss-result-text');
    
    resultText.innerHTML = `
        <div style="margin-bottom: 15px;">
            <strong>ü™ô Toss Result: ${data.toss_result.toUpperCase()}</strong><br>
            ${data.calling_team} called ${data.call}<br>
            üèÜ <span style="color: #ffd700;">${data.toss_winner} wins the toss!</span>
        </div>
        <p>Choose what to do:</p>
    `;
    
    tossDecisionSection.style.display = 'block';
    
    // Update ticker
    updateTicker(`ü™ô ${data.toss_winner} wins the toss ‚Ä¢ üéØ Deciding whether to bat or bowl first`);
}

function makeTossDecision(decision) {
    fetch(`/api/matches/${MATCH_DATA.match_id}/toss-decision`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify({
            decision: decision
        })
    })
    .then(response => response.json())
    .then(data => {
        if (data.error) {
            showNotification(data.error, 'error');
        } else {
            showNotification('Decision made!', 'success');
        }
    })
    .catch(error => {
        showNotification('Error making decision', 'error');
        console.error('Error:', error);
    });
}

function handleTossDecision(data) {
    // Hide toss decision section
    document.getElementById('toss-decision-section').style.display = 'none';
    
    // Show start section
    const startSection = document.getElementById('start-section');
    const battingOrderText = document.getElementById('batting-order-text');
    
    battingOrderText.innerHTML = `
        <div style="margin-bottom: 15px;">
            <strong>üèè ${data.batting_first} will bat first</strong><br>
            <strong>‚öæ ${data.bowling_first} will bowl first</strong>
        </div>
        <p>Ready to start the match?</p>
    `;
    
    startSection.style.display = 'block';
    
    // Update match state
    matchState.battingTeam = data.batting_first === MATCH_DATA.team1.short_name ? MATCH_DATA.team1 : MATCH_DATA.team2;
    matchState.firstInningsBattingTeam = matchState.battingTeam; // Store first innings batting team
    matchState.battingOrderPlayers = [];
    matchState.bowlingTeam = data.batting_first === MATCH_DATA.team1.short_name ? MATCH_DATA.team2 : MATCH_DATA.team1;
    
    // Update ticker
    updateTicker(`üèè ${data.batting_first} to bat first ‚Ä¢ ‚öæ ${data.bowling_first} to bowl ‚Ä¢ üöÄ Match starting soon`);
}

function startMatch() {
    fetch(`/api/matches/${MATCH_DATA.match_id}/start`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        }
    })
    .then(response => response.json())
    .then(data => {
        if (data.error) {
            showNotification(data.error, 'error');
        } else {
            showNotification('Match started!', 'success');
        }
    })
    .catch(error => {
        showNotification('Error starting match', 'error');
        console.error('Error:', error);
    });
}

function handleMatchStart(data) {
    // Hide start section
    document.getElementById('start-section').style.display = 'none';
    
    // Show live controls
    document.getElementById('live-controls').style.display = 'block';
    
    // Show match elements
    document.getElementById('player-status').style.display = 'grid';
    document.getElementById('over-display').style.display = 'block';
    
    // Update status
    updateMatchStatus('live');
    
    // Initialize first innings
    matchState.currentInnings = 1;
    matchState.totalRuns = 0;
    matchState.wicketsLost = 0;
    matchState.ballsFaced = 0;
    matchState.currentBalls = 0;
    matchState.firstInningsBattingOrderPlayers = []; // Initialize first innings batting order
    matchState.battingOrderPlayers = matchState.firstInningsBattingOrderPlayers; // Point to first innings array
    matchState.wicketkeeper = matchState.bowlingTeam.players.find(p => p.is_wicketkeeper);
    
    // Initialize stats tracking for first innings
    matchState.scorecardManager.initializeInnings(1, matchState.battingTeam, matchState.bowlingTeam);
    
    // Clear projection info and previous result
    document.getElementById('projection-info').textContent = '';
    matchState.matchResult = null;
    
    // Initialize match display
    updateMatchDisplay();
    
    // Update ticker
    updateTicker(`üèè Match has begun! ‚Ä¢ First innings in progress ‚Ä¢ ${data.batting_team} batting`);
    
    // Prompt for opening batsmen and bowler selection
    selectOpeningPlayers();
}

function selectOpeningPlayers() {
    // Open modal for user to select opening players
    if (matchState.battingTeam && matchState.bowlingTeam) {
        openPlayerSelectionModal();
    } else {
        showNotification('Teams not loaded yet', 'error');
    }
}

function openPlayerSelectionModal() {
    const modal = document.getElementById('player-modal');
    
    // Populate dropdowns with available players
    populatePlayerDropdowns();
    
    // Show modal
    modal.style.display = 'block';
    
    // Add event listeners for player selection changes
    document.getElementById('striker-select').addEventListener('change', updatePlayerPreview);
    document.getElementById('non-striker-select').addEventListener('change', updatePlayerPreview);
    document.getElementById('bowler-select').addEventListener('change', updatePlayerPreview);
}

function populatePlayerDropdowns() {
    const strikerSelect = document.getElementById('striker-select');
    const nonStrikerSelect = document.getElementById('non-striker-select');
    const bowlerSelect = document.getElementById('bowler-select');
    
    // Clear existing options
    strikerSelect.innerHTML = '<option value="">Choose striker...</option>';
    nonStrikerSelect.innerHTML = '<option value="">Choose non-striker...</option>';
    bowlerSelect.innerHTML = '<option value="">Choose bowler...</option>';
    
    // Populate batsmen dropdowns
    matchState.battingTeam.players.forEach(player => {
        const strikerOption = document.createElement('option');
        strikerOption.value = player.id;
        strikerOption.textContent = `${player.name} (vs Pace: ${player.batting_vs_pace}, vs Spin: ${player.batting_vs_spin}, Aggression: ${player.batting_aggression})`;
        strikerSelect.appendChild(strikerOption);
        
        const nonStrikerOption = document.createElement('option');
        nonStrikerOption.value = player.id;
        nonStrikerOption.textContent = `${player.name} (vs Pace: ${player.batting_vs_pace}, vs Spin: ${player.batting_vs_spin}, Aggression: ${player.batting_aggression})`;
        nonStrikerSelect.appendChild(nonStrikerOption);
    });
    
    // Populate bowler dropdown
    matchState.bowlingTeam.players.forEach(player => {
        const bowlerOption = document.createElement('option');
        bowlerOption.value = player.id;
        bowlerOption.textContent = `${player.name} (Bowl: ${player.bowling_type}, ${player.bowling_skill})`;
        bowlerSelect.appendChild(bowlerOption);
    });
}

function updatePlayerPreview() {
    const strikerId = document.getElementById('striker-select').value;
    const nonStrikerId = document.getElementById('non-striker-select').value;
    const bowlerId = document.getElementById('bowler-select').value;
    
    const previewDiv = document.getElementById('player-preview');
    let previewHTML = '<h4>üìä Player Preview</h4>';
    
    if (strikerId) {
        const striker = matchState.battingTeam.players.find(p => p.id == strikerId);
        previewHTML += `
            <div class="player-preview-item">
                <strong>üèè Striker:</strong> ${striker.name}<br>
                Skill vs Pace: ${striker.batting_vs_pace} | Skill vs Spin: ${striker.batting_vs_spin} | Aggression: ${striker.batting_aggression}
            </div>
        `;
    }
    
    if (nonStrikerId) {
        const nonStriker = matchState.battingTeam.players.find(p => p.id == nonStrikerId);
        previewHTML += `
            <div class="player-preview-item">
                <strong>üèè Non-striker:</strong> ${nonStriker.name}<br>
                Skill vs Pace: ${nonStriker.batting_vs_pace} | Skill vs Spin: ${nonStriker.batting_vs_spin} | Aggression: ${nonStriker.batting_aggression}
            </div>
        `;
    }
    
    if (bowlerId) {
        const bowler = matchState.bowlingTeam.players.find(p => p.id == bowlerId);
        previewHTML += `
            <div class="player-preview-item">
                <strong>‚öæ Bowler:</strong> ${bowler.name}<br>
                Bowling: ${bowler.bowling_skill} | ${bowler.bowling_type}
            </div>
        `;
    }
    
    previewDiv.innerHTML = previewHTML;
}

function confirmPlayerSelection() {
    const strikerId = document.getElementById('striker-select').value;
    const nonStrikerId = document.getElementById('non-striker-select').value;
    const bowlerId = document.getElementById('bowler-select').value;
    
    // Validate selection
    if (!strikerId || !nonStrikerId || !bowlerId) {
        showNotification('Please select all three players', 'error');
        return;
    }
    
    if (strikerId === nonStrikerId) {
        showNotification('Striker and non-striker must be different players', 'error');
        return;
    }
    
    // Set the selected players
    matchState.striker = matchState.battingTeam.players.find(p => p.id == strikerId);
    matchState.battingOrderPlayers.push(matchState.striker);
    if (matchState.currentInnings === 1) {
        matchState.firstInningsBattingOrderPlayers.push(matchState.striker);
    } else {
        matchState.secondInningsBattingOrderPlayers.push(matchState.striker);
    }
    matchState.nonStriker = matchState.battingTeam.players.find(p => p.id == nonStrikerId);
    matchState.battingOrderPlayers.push(matchState.nonStriker);
    if (matchState.currentInnings === 1) {
        matchState.firstInningsBattingOrderPlayers.push(matchState.nonStriker);
    } else {
        matchState.secondInningsBattingOrderPlayers.push(matchState.nonStriker);
    }
    matchState.currentBowler = matchState.bowlingTeam.players.find(p => p.id == bowlerId);
    
    // Close modal
    closePlayerModal();
    
    // Update display
    updatePlayerDisplay();
    
    // Show confirmation
    showNotification(`Opening players selected: ${matchState.striker.name}, ${matchState.nonStriker.name}, ${matchState.currentBowler.name}`, 'success');
}

function closePlayerModal() {
    const modal = document.getElementById('player-modal');
    modal.style.display = 'none';
    
    // Remove event listeners
    document.getElementById('striker-select').removeEventListener('change', updatePlayerPreview);
    document.getElementById('non-striker-select').removeEventListener('change', updatePlayerPreview);
    document.getElementById('bowler-select').removeEventListener('change', updatePlayerPreview);
}

function simulateDelivery() {
    if (!matchState.striker || !matchState.nonStriker || !matchState.currentBowler) {
        showNotification('Please select players first', 'error');
        return;
    }
    
    // This is where you'd integrate with your Python cricket simulation logic
    // For now, we'll create a mock delivery
    const mockDelivery = generateMockDelivery();
    matchState.fielder = matchState.bowlingTeam.players[Math.floor(Math.random() * 11)];
    
    // Send delivery to server for processing
    fetch(`/api/matches/${MATCH_DATA.match_id}/simulate-delivery`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify({
            bowler_id: matchState.currentBowler.id,
            striker_id: matchState.striker.id,
            non_striker_id: matchState.nonStriker.id,
            fielder_id: matchState.fielder.id,
            wicketkeeper_id: matchState.wicketkeeper.id
        })
    })
    .then(response => response.json())
        .then(data => {
        if (data.error) {
            showNotification(data.error, 'error');
        } else {
            // Delivery result will be handled by WebSocket
            console.log('Server response received:', data);
            console.log('Waiting for WebSocket delivery_update event...');
            
            // // Check if we have server data or need to use mock
            // if (data && data.delivery_result) {
            //     console.log('Using server data');
            //     console.log('Current balls:', matchState.currentBalls);
            //     deliveryData = processDeliveryData(data);
            // } else {
            //     console.log('Using mock data');
            //     deliveryData = mockDelivery;
            // }
            
            // handleDeliveryUpdate({
            //     match_id: MATCH_DATA.match_id,
            //     ...deliveryData
            // });

            // Don't call handleDeliveryUpdate here - let WebSocket handle it
            // This prevents duplicate processing
        }
    })
    .catch(error => {
        // For demo purposes, if the API isn't implemented yet, use mock data
        console.log('Using mock delivery data');
        handleDeliveryUpdate({
            match_id: MATCH_DATA.match_id,
            ...mockDelivery
        });
    });
}

function processDeliveryType(runsScored, isWicket, extras) {
    let delivery_type = "dot";
    // Try to access the data with fallbacks
    if (isWicket) {
        delivery_type = "wicket";
    } else if (extras > 0) {
        delivery_type = "wide"; // Handle no ball
    } else if (runsScored > 0) {
        if (runsScored == 4) {
            delivery_type = "four";
        } else if (runsScored == 6) {
            delivery_type = "six";
        } else {
            delivery_type = "runs";
        }
    }
    return delivery_type;
}

function processDeliveryData(data) {
    // Debug: Log the entire data structure
    console.log('Raw data received:', data);
    console.log('Data keys:', Object.keys(data));
    
    // Check if data.delivery_result exists
    if (data.delivery_result) {
        console.log('delivery_result keys:', Object.keys(data.delivery_result));
    }
    
    let delivery_type = "dot";
    // Try to access the data with fallbacks
    if (data.delivery_result && data.delivery_result.is_wicket) {
        delivery_type = "wicket";
    } else if (data.delivery_result && data.delivery_result.extras > 0) {
        delivery_type = "wide"; // Handle no ball
    } else if (data.delivery_result && data.delivery_result.runs_scored > 0) {
        if (data.delivery_result.runs_scored == 4) {
            delivery_type = "four";
        } else if (data.delivery_result.runs_scored == 6) {
            delivery_type = "six";
        } else {
            delivery_type = "runs";
        }
    }

    console.log('Delivery type:', delivery_type);

    const outcome = {
        type: delivery_type,
        runs: data.delivery_result?.runs_scored || data.runs || 0,
        extras: data.delivery_result?.extras || data.extras || 0,
        isWicket: data.delivery_result?.is_wicket || data.isWicket || false
    };
    
    console.log('Processed outcome:', outcome);
    
    return {
        ...outcome,
        ballNumber: (matchState.currentBalls || 0) + 1,
        overNumber: Math.floor((matchState.currentBalls || 0) / 6) + 1
    };
}

function generateMockDelivery() {
    // Mock delivery generation for demo purposes
    const outcomes = [
        { type: 'dot', runs: 0, extras: 0, isWicket: false },
        { type: 'runs', runs: 1, extras: 0, isWicket: false },
        { type: 'runs', runs: 2, extras: 0, isWicket: false },
        { type: 'runs', runs: 3, extras: 0, isWicket: false },
        { type: 'four', runs: 4, extras: 0, isWicket: false },
        { type: 'six', runs: 6, extras: 0, isWicket: false },
        { type: 'wicket', runs: 0, extras: 0, isWicket: true },
        { type: 'wide', runs: 1, extras: 1, isWicket: false },
        { type: 'noball', runs: 1, extras: 1, isWicket: false }
    ];
    
    const weights = [30, 25, 15, 8, 12, 5, 3, 1, 1]; // Probability weights
    const randomIndex = weightedRandom(weights);
    
    const mockDelivery = {
        ...outcomes[randomIndex],
        ballNumber: (matchState.currentBalls || 0) + 1,
        overNumber: Math.floor((matchState.currentBalls || 0) / 6) + 1
    };
    
    console.log('Current balls:', matchState.currentBalls);
    console.log('Generated mock delivery:', mockDelivery);
    return mockDelivery;
}

function weightedRandom(weights) {
    const totalWeight = weights.reduce((sum, weight) => sum + weight, 0);
    let random = Math.random() * totalWeight;
    
    for (let i = 0; i < weights.length; i++) {
        random -= weights[i];
        if (random <= 0) {
            return i;
        }
    }
    return weights.length - 1;
}

function handleDeliveryUpdate(data) {
    // Add ball to display
    addBallToOver(data);
    
    // Update scores and stats
    updateScoreAfterDelivery(data);
    
    // Update player stats
    updatePlayerStats(data);
    
    // Update ticker with commentary
    updateTickerWithDelivery(data);
    
    // Check for wicket or over completion
    if (data.isWicket) {
        // Show wicket result first, then prompt for next action
        showDeliveryResult(data, 'wicket');
    } else if ((data.ballNumber % 6 === 0) && data.extras === 0) {
        // Show over completion result first, then prompt for next action
        showDeliveryResult(data, 'over');
    } else {
        // Regular delivery - continue normally
        // Check for innings completion
        checkInningsCompletion();
    }
}

function showDeliveryResult(data, resultType) {
    // Disable the "Next Ball" button temporarily
    const nextBallBtn = document.getElementById('next-ball-btn');
    nextBallBtn.disabled = true;
    
    // Show result message
    // let resultMessage = '';
    // if (resultType === 'wicket') {
    //     resultMessage = `üî• WICKET! ${matchState.striker.name} is out!`;
    // } else if (resultType === 'over') {
    //     resultMessage = `üèè Over completed!`;
    // }
    
    // // Update ticker with result
    // updateTicker(resultMessage);
    
    // Wait 2 seconds to show the result, then enable action button
    setTimeout(() => {
        if (resultType === 'wicket') {
            // Change button to "Select Next Batsman"
            nextBallBtn.textContent = 'üèè Select Next Batsman';
            nextBallBtn.onclick = () => {
                handleWicket(data);
            };
        } else if (resultType === 'over') {
            // Change button to "Select Next Bowler"
            nextBallBtn.textContent = '‚öæ Select Next Bowler';
            nextBallBtn.onclick = () => {
                completeOver();
            };
        }
        
        // Re-enable button
        nextBallBtn.disabled = false;
    }, 500);
}

function addBallToOver(data) {
    const ballsContainer = document.getElementById('balls-container');
    const ball = document.createElement('div');
    ball.className = `ball ${data.type}`;
    
    if (data.isWicket) {
        ball.textContent = 'W';
        ball.className = 'ball wicket';
    } else if (data.type === 'wide' || data.type === 'noball') {
        ball.textContent = data.type === 'wide' ? 'Wd' : 'Nb';
    } else {
        ball.textContent = data.runs === 0 ? '‚Ä¢' : data.runs;
    }
    
    ballsContainer.appendChild(ball);
    
    // Update over number display - only count legal deliveries
    const legalBalls = Array.from(ballsContainer.children).filter(ball => 
        !ball.classList.contains('wide') && !ball.classList.contains('noball')
    ).length;
    
    const overNum = Math.floor((legalBalls - 1) / 6) + 1;
    const ballInOver = ((legalBalls - 1) % 6) + 1;
    
    document.getElementById('over-number').textContent = `Over ${overNum}.${ballInOver}`;
}

function updateScoreAfterDelivery(data) {
    // Update team score (this would come from server in real implementation)
    matchState.totalRuns = (matchState.totalRuns || 0) + data.runs + data.extras;
    // matchState.wicketsLost = (matchState.wicketsLost || 0) + (data.isWicket ? 1 : 0);  // No need to double-count wicket fall
    
    // Only increment balls faced for legal deliveries (no extras)
    if (data.extras === 0) {
        matchState.ballsFaced = (matchState.ballsFaced || 0) + 1;
        matchState.currentBalls = (matchState.currentBalls || 0) + 1;
    }
    
    // Update display
    const team1Score = document.getElementById('team1-score');
    const team1RR = document.getElementById('team1-rr');
    
    team1Score.textContent = `${matchState.totalRuns}/${matchState.wicketsLost}`;

    
    const overs = Math.floor(matchState.ballsFaced / 6) + (matchState.ballsFaced % 6) / 10;
    const runRate = (matchState.ballsFaced > 0) ? (matchState.totalRuns * 6 / matchState.ballsFaced).toFixed(2) : '0.00';

    console.log('Current balls:', matchState.currentBalls);
    console.log('Balls faced:', matchState.ballsFaced);
    console.log('Overs:', overs);

    if (matchState.currentInnings === 1) {
        // First innings - show run rate only        
        team1RR.textContent = `RR: ${runRate}`;
        
        // Show projected score for first innings
        const projectedScore = Math.round(runRate * MATCH_DATA.max_overs);
        document.getElementById('projection-info').textContent = `Projected score: ${projectedScore}`;
    } else {
        // Second innings - show run rate and required run rate
        const remainingRuns = matchState.target - matchState.totalRuns;
        const remainingBalls = (MATCH_DATA.max_overs * 6) - matchState.ballsFaced;
        const requiredRunRate = remainingBalls > 0 ? (remainingRuns * 6 / remainingBalls).toFixed(2) : '0.00';
        
        team1RR.textContent = `RR: ${runRate} | RRR: ${requiredRunRate}`;
        
        // Show runs needed for second innings
        document.getElementById('projection-info').textContent = `Need ${remainingRuns} runs from ${remainingBalls} balls`;
    }
    
    // Update overs display
    document.getElementById('match-overs').textContent = `${overs.toFixed(1)}/${MATCH_DATA.max_overs} overs`;
    
    // Check if target is reached in second innings
    if (matchState.currentInnings === 2 && matchState.totalRuns >= matchState.target) {
        updateTicker(`üéØ TARGET ACHIEVED! ${matchState.battingTeam.short_name} wins the match!`);
        setTimeout(() => {
            endInnings();
        }, 2000);
    }
}

function updatePlayerStats(data) {
    // Update stats using the new scorecard manager
    if (matchState.striker) {
        // Update batting stats
        matchState.scorecardManager.updateBattingStats(
            matchState.currentInnings,
            matchState.striker.id,
            data.runs,
            data.isWicket,
            data.dismissal_type,
            matchState.currentBowler,
            matchState.fielder,
            data.extras || 0
        );
        
        // Get updated stats for display
        const battingScore = matchState.scorecardManager.getBattingScore(matchState.currentInnings, matchState.striker.id);
        const sr = battingScore.getStrikeRate().toFixed(1);
        
        document.getElementById('striker-name').textContent = matchState.striker.name;
        document.getElementById('striker-stats').innerHTML = 
            `${battingScore.runsScored}* (${battingScore.ballsFaced}) | SR: ${sr}<br>4s: ${battingScore.foursHit} ‚Ä¢ 6s: ${battingScore.sixesHit}`;
    }

    // Update bowler stats
    if (matchState.currentBowler) {
        // Update bowling stats
        matchState.scorecardManager.updateBowlingStats(
            matchState.currentInnings,
            matchState.currentBowler.id,
            data.runs,
            data.isWicket,
            data.type === 'wide' ? 'wide' : data.type === 'noball' ? 'noball' : null
        );
        
        // Get updated stats for display
        const bowlingFigures = matchState.scorecardManager.getBowlingFigures(matchState.currentInnings, matchState.currentBowler.id);
        
        document.getElementById('bowler-name').textContent = matchState.currentBowler.name;
    }
    
    // Swap strike on odd runs
    if (data.runs % 2 === 1 && !data.isWicket) {
        swapStrike();
    }
    updateMatchDisplay();
}

function swapStrike() {
    const temp = matchState.striker;
    matchState.striker = matchState.nonStriker;
    matchState.nonStriker = temp;
    
    updatePlayerDisplay();
}

function updatePlayerDisplay() {
    const strikerDiv = document.getElementById('striker');
    const nonStrikerDiv = document.getElementById('non-striker');
    
    // Remove on-strike class from both
    strikerDiv.classList.remove('on-strike');
    nonStrikerDiv.classList.remove('on-strike');
    
    // Add on-strike class to current striker
    strikerDiv.classList.add('on-strike');
    
    // Update names and stats
    if (matchState.striker) {
        document.getElementById('striker-name').textContent = matchState.striker.name;
        // Get stats from scorecardManager for current innings
        const strikerStats = matchState.scorecardManager.getBattingScore(matchState.currentInnings, matchState.striker.id);
        if (strikerStats) {
            const strikerSR = strikerStats.ballsFaced > 0 ? 
                (strikerStats.runsScored / strikerStats.ballsFaced * 100).toFixed(1) : '0.0';
            document.getElementById('striker-stats').innerHTML = 
                `${strikerStats.runsScored}* (${strikerStats.ballsFaced}) | SR: ${strikerSR}<br>4s: ${strikerStats.foursHit} ‚Ä¢ 6s: ${strikerStats.sixesHit}`;
        } else {
            // Fallback if no stats found
            document.getElementById('striker-stats').innerHTML = 
                `0* (0) | SR: 0.0<br>4s: 0 ‚Ä¢ 6s: 0`;
        }
    }
    
    if (matchState.nonStriker) {
        document.getElementById('non-striker-name').textContent = matchState.nonStriker.name;
        // Get stats from scorecardManager for current innings
        const nonStrikerStats = matchState.scorecardManager.getBattingScore(matchState.currentInnings, matchState.nonStriker.id);
        if (nonStrikerStats) {
            const nonStrikerSR = nonStrikerStats.ballsFaced > 0 ? 
                (nonStrikerStats.runsScored / nonStrikerStats.ballsFaced * 100).toFixed(1) : '0.0';
            document.getElementById('non-striker-stats').innerHTML = 
                `${nonStrikerStats.runsScored}* (${nonStrikerStats.ballsFaced}) | SR: ${nonStrikerSR}<br>4s: ${nonStrikerStats.foursHit} ‚Ä¢ 6s: ${nonStrikerStats.sixesHit}`;
        } else {
            // Fallback if no stats found
            document.getElementById('non-striker-stats').innerHTML = 
                `0* (0) | SR: 0.0<br>4s: 0 ‚Ä¢ 6s: 0`;
        }
    }
}

function updateTickerWithDelivery(data) {
    let commentary = '';
    
    if (data.isWicket) {
        // Enhanced wicket commentary with dismissal type
        let dismissalText = '';
        if (data.dismissal_type) {
            switch(data.dismissal_type) {
                case 'bowled':
                    dismissalText = 'BOWLED!';
                    break;
                case 'lbw':
                    dismissalText = 'LBW!';
                    break;
                case 'caught':
                    dismissalText = 'CAUGHT!';
                    break;
                case 'stumped':
                    dismissalText = 'STUMPED!';
                    break;
                case 'caught behind':
                    dismissalText = 'CAUGHT BEHIND!';
                    break;
                default:
                    dismissalText = 'OUT!';
            }
        } else {
            dismissalText = 'OUT!';
        }
        
        commentary = `üî• WICKET! ${matchState.striker.name} ${dismissalText} ‚Ä¢ ${matchState.currentBowler.name} strikes`;
        
        // Show exciting wicket animation
        showEventAnimation('WICKET!', 'wicket', dismissalText);
        
    } else if (data.runs === 6) {
        commentary = `üöÄ SIX! ${matchState.striker.name} sends it into the stands ‚Ä¢ Magnificent shot`;
        
        // Show exciting six animation
        showEventAnimation('SIX!', 'six', 'üöÄ');
        
    } else if (data.runs === 4) {
        commentary = `üéØ FOUR! ${matchState.striker.name} finds the boundary ‚Ä¢ Excellent timing`;
        
        // Show exciting four animation
        showEventAnimation('FOUR!', 'four', 'üéØ');
    } else if (data.type === 'wide') {
        commentary = `‚ÜîÔ∏è Wide ball ‚Ä¢ Extra run to the batting side`;
    } else if (data.type === 'noball') {
        commentary = `‚ùå No ball ‚Ä¢ Free hit coming up`;
    } else if (data.runs === 0) {
        commentary = `‚ö´ Dot ball ‚Ä¢ Good bowling by ${matchState.currentBowler.name}`;
    } else {
        commentary = `‚ñ∂Ô∏è ${data.runs} run${data.runs > 1 ? 's' : ''} ‚Ä¢ ${matchState.striker.name} keeps the scoreboard ticking`;
    }
    
    updateTicker(commentary);
}

function handleWicket(data) {
    // Mark current striker as out
    if (matchState.striker) {
        matchState.striker.isOut = true;
    }
    
    // Increment wickets
    matchState.wicketsLost = (matchState.wicketsLost || 0) + 1; // No need to double-count wicket fall
    
    // Check if innings should end
    if (matchState.wicketsLost >= 10) {
        endInnings();
        return;
    }
    
    // Check if this wicket occurred on the last ball of an over
    const currentBalls = matchState.currentBalls || 0;
    const isLastBallOfOver = (currentBalls % 6 === 0);
    
    console.log(`Wicket on ball ${currentBalls}, isLastBallOfOver: ${isLastBallOfOver}`);
    
    if (isLastBallOfOver) {
        // Wicket on last ball of over - need both new batsman AND new bowler
        console.log('Wicket on last ball of over - will select new batsman then new bowler');
        selectNewBatsman();
        // Note: The bowler selection will be handled in confirmNewBatsman() after batsman selection
    } else {
        // Regular wicket - just select new batsman
        console.log('Regular wicket - just selecting new batsman');
        selectNewBatsman();
    }
    
    // Reset button to "Next Ball" after selection
    resetNextBallButton();
}

function selectNewBatsman() {
    // Get available batsmen (not out, not currently batting, not already in batting order)
    const availableBatsmen = matchState.battingTeam.players.filter(player => 
        !player.isOut && 
        player.id !== matchState.striker.id && 
        player.id !== matchState.nonStriker.id &&
        !matchState.battingOrderPlayers.some(battingPlayer => battingPlayer.id === player.id)
    );
    
    if (availableBatsmen.length > 0) {
        // Open modal for user to select new batsman
        openNewBatsmanModal(availableBatsmen);
    } else {
        // No more batsmen available - innings should end
        showNotification('No more batsmen available - innings ending', 'info');
        endInnings();
    }
}

function openNewBatsmanModal(availableBatsmen) {
    const modal = document.getElementById('player-modal');
    
    // Update modal title and content for new batsman selection
    document.getElementById('modal-title').textContent = 'üèè Select New Batsman';
    
    // Clear previous content
    const modalContent = modal.querySelector('.modal-content');
    
    // Create new batsman selection interface
    modalContent.innerHTML = `
        <h3 id="modal-title">üèè Select New Batsman</h3>
        
        <div class="selection-section">
            <h4>üîÑ New Batsman Selection</h4>
            <p>Choose who comes to the crease next:</p>
            
            <div class="player-grid">
                <div class="player-column">
                    <label>New Batsman:</label>
                    <select id="new-batsman-select" class="player-select-dropdown">
                        <option value="">Choose new batsman...</option>
                    </select>
                </div>
            </div>
        </div>
        
        <!-- Player Stats Preview -->
        <div class="player-preview" id="player-preview">
            <!-- Player stats will be shown here -->
        </div>
        
        <!-- Action Buttons -->
        <div class="modal-actions">
            <button class="btn btn-primary" onclick="confirmNewBatsman()">‚úÖ Confirm Selection</button>
            <button class="btn btn-secondary" onclick="closeNewBatsmanModal()">‚ùå Cancel</button>
        </div>
    `;
    
    // Populate dropdown with available batsmen
    populateNewBatsmanDropdown(availableBatsmen);
    
    // Show modal
    modal.style.display = 'block';
    
    // Add event listener for batsman selection changes
    document.getElementById('new-batsman-select').addEventListener('change', updateNewBatsmanPreview);
}

function populateNewBatsmanDropdown(availableBatsmen) {
    const batsmanSelect = document.getElementById('new-batsman-select');
    
    // Clear existing options
    batsmanSelect.innerHTML = '<option value="">Choose new batsman...</option>';
    
    // Populate dropdown with available batsmen
    availableBatsmen.forEach(player => {
        const option = document.createElement('option');
        option.value = player.id;
        option.textContent = `${player.name} (vs Pace: ${player.batting_vs_pace}, vs Spin: ${player.batting_vs_spin}, Aggression: ${player.batting_aggression})`;
        batsmanSelect.appendChild(option);
    });
}

function updateNewBatsmanPreview() {
    const batsmanId = document.getElementById('new-batsman-select').value;
    const previewDiv = document.getElementById('player-preview');
    
    if (batsmanId) {
        const batsman = matchState.battingTeam.players.find(p => p.id == batsmanId);
        previewDiv.innerHTML = `
            <h4>üìä New Batsman Preview</h4>
            <div class="player-preview-item">
                <strong>üèè New Batsman:</strong> ${batsman.name}<br>
                Skill vs Pace: ${batsman.batting_vs_pace} | Skill vs Spin: ${batsman.batting_vs_spin} | Aggression: ${batsman.batting_aggression}
            </div>
        `;
    } else {
        previewDiv.innerHTML = '<h4>üìä New Batsman Preview</h4><p>Select a batsman to see their stats</p>';
    }
}

function confirmNewBatsman() {
    const batsmanId = document.getElementById('new-batsman-select').value;
    
    if (!batsmanId) {
        showNotification('Please select a new batsman', 'error');
        return;
    }
    
    // Get the selected batsman
    const newBatsman = matchState.battingTeam.players.find(p => p.id == batsmanId);
    
    // Set as new striker
    matchState.striker = newBatsman;
    if (matchState.currentInnings === 1) {
        matchState.firstInningsBattingOrderPlayers.push(matchState.striker);
    } else {
        matchState.secondInningsBattingOrderPlayers.push(matchState.striker);
    }
    matchState.battingOrderPlayers.push(matchState.striker);
    
    // Initialize batsman stats in scorecardManager (stats are already initialized to 0)
    // No need to manually set stats - they're managed by the scorecardManager
    
    // Close modal
    closeNewBatsmanModal();
    
    // Update display
    updatePlayerDisplay();
    
    // Show confirmation
    showNotification(`${matchState.striker.name} comes to the crease`, 'success');
    
    // Update ticker
    updateTicker(`üèè ${matchState.striker.name} is the new batsman ‚Ä¢ Ready to face the next ball`);
    
    // Check if we need to select a new bowler (for wicket on last ball of over)
    const currentBalls = matchState.currentBalls || 0;
    const isLastBallOfOver = (currentBalls % 6 === 0);
    
    if (isLastBallOfOver) {
        console.log('Batsman selected, now selecting new bowler for over completion');
        setTimeout(() => {
            completeOver();
        }, 500);
    }
}

function closeNewBatsmanModal() {
    const modal = document.getElementById('player-modal');
    modal.style.display = 'none';
    
    // Remove event listener
    const batsmanSelect = document.getElementById('new-batsman-select');
    if (batsmanSelect) {
        batsmanSelect.removeEventListener('change', updateNewBatsmanPreview);
    }
    
    // Reset modal to original opening players selection content
    resetModalToOriginal();
}

function resetModalToOriginal() {
    const modal = document.getElementById('player-modal');
    const modalContent = modal.querySelector('.modal-content');
    
    // Restore original modal content for opening players selection
    modalContent.innerHTML = `
        <h3 id="modal-title">Select Opening Players</h3>
        
        <!-- Batsmen Selection -->
        <div class="selection-section">
            <h4>üèè Select Opening Batsmen</h4>
            <div class="player-grid">
                <div class="player-column">
                    <label>Striker (on strike):</label>
                    <select id="striker-select" class="player-select-dropdown">
                        <option value="">Choose striker...</option>
                    </select>
                </div>
                <div class="player-column">
                    <label>Non-striker:</label>
                    <select id="non-striker-select" class="player-select-dropdown">
                        <option value="">Choose non-striker...</option>
                    </select>
                </div>
            </div>
        </div>
        
        <!-- Bowler Selection -->
        <div class="selection-section">
            <h4>‚öæ Select Opening Bowler</h4>
            <div class="player-grid">
                <div class="player-column">
                    <label>Opening Bowler:</label>
                    <select id="bowler-select" class="player-select-dropdown">
                        <option value="">Choose bowler...</option>
                    </select>
                </div>
            </div>
        </div>
        
        <!-- Player Stats Preview -->
        <div class="player-preview" id="player-preview">
            <!-- Player stats will be shown here -->
        </div>
        
        <!-- Action Buttons -->
        <div class="modal-actions">
            <button class="btn btn-primary" onclick="confirmPlayerSelection()">‚úÖ Confirm Selection</button>
            <button class="btn btn-secondary" onclick="closePlayerModal()">‚ùå Cancel</button>
        </div>
    `;
    
    // Re-populate the dropdowns and re-attach event listeners
    if (matchState.battingTeam && matchState.bowlingTeam) {
        populatePlayerDropdowns();
        document.getElementById('striker-select').addEventListener('change', updatePlayerPreview);
        document.getElementById('non-striker-select').addEventListener('change', updatePlayerPreview);
        document.getElementById('bowler-select').addEventListener('change', updatePlayerPreview);
    }
}

function completeOver() {
    // Clear balls display
    document.getElementById('balls-container').innerHTML = '';
    
    // Swap strike at end of over
    swapStrike();
    
    // Update bowler overs
    if (matchState.currentBowler) {
        matchState.currentBowler.oversBowled = Math.floor(matchState.currentBowler.oversBowled || 0) + 1;
    }
    
    // Check if innings should end after this over
    const totalBalls = matchState.ballsFaced || 0;
    const maxBalls = MATCH_DATA.max_overs * 6;
    
    if (totalBalls >= maxBalls) {
        // Innings completed due to overs
        showNotification('Innings completed - all overs bowled!', 'info');
        setTimeout(() => {
            endInnings();
        }, 1000);
    } else {
        // More overs to go - select new bowler
        selectNewBowler();
        showNotification('Over completed!', 'info');
    }
    
    // Reset button to "Next Ball" after selection
    resetNextBallButton();
}

function resetNextBallButton() {
    const nextBallBtn = document.getElementById('next-ball-btn');
    nextBallBtn.textContent = 'üéØ Next Ball';
    nextBallBtn.onclick = simulateDelivery;
    nextBallBtn.disabled = false;
}

function selectNewBowler() {
    // Get available bowlers (haven't bowled max overs, not current bowler)
    const maxOvers = MATCH_DATA.match_type === 'T20' ? 4 : 10;
    const availableBowlers = matchState.bowlingTeam.players.filter(player => 
        (player.oversBowled || 0) < maxOvers && 
        player.id !== matchState.currentBowler.id
    );
    
    if (availableBowlers.length > 0) {
        // Open modal for user to select new bowler
        openNewBowlerModal(availableBowlers);
    } else {
        // No more bowlers available
        showNotification('No more bowlers available - all have bowled their maximum overs', 'info');
    }
}

function openNewBowlerModal(availableBowlers) {
    const modal = document.getElementById('player-modal');
    
    // Update modal title and content for new bowler selection
    document.getElementById('modal-title').textContent = '‚öæ Select New Bowler';
    
    // Clear previous content
    const modalContent = modal.querySelector('.modal-content');
    
    // Create new bowler selection interface
    modalContent.innerHTML = `
        <h3 id="modal-title">‚öæ Select New Bowler</h3>
        
        <div class="selection-section">
            <h4>üîÑ New Bowler Selection</h4>
            <p>Choose who will bowl the next over:</p>
            
            <div class="player-grid">
                <div class="player-column">
                    <label>New Bowler:</label>
                    <select id="new-bowler-select" class="player-select-dropdown">
                        <option value="">Choose new bowler...</option>
                    </select>
                </div>
            </div>
        </div>
        
        <!-- Player Stats Preview -->
        <div class="player-preview" id="player-preview">
            <!-- Player stats will be shown here -->
        </div>
        
        <!-- Action Buttons -->
        <div class="modal-actions">
            <button class="btn btn-primary" onclick="confirmNewBowler()">‚úÖ Confirm Selection</button>
            <button class="btn btn-secondary" onclick="closeNewBowlerModal()">‚ùå Cancel</button>
        </div>
    `;
    
    // Populate dropdown with available bowlers
    populateNewBowlerDropdown(availableBowlers);
    
    // Show modal
    modal.style.display = 'block';
    
    // Add event listener for bowler selection changes
    document.getElementById('new-bowler-select').addEventListener('change', updateNewBowlerPreview);
}

function populateNewBowlerDropdown(availableBowlers) {
    const bowlerSelect = document.getElementById('new-bowler-select');
    
    // Clear existing options
    bowlerSelect.innerHTML = '<option value="">Choose new bowler...</option>';
    
    // Populate dropdown with available bowlers
    availableBowlers.forEach(player => {
        const option = document.createElement('option');
        option.value = player.id;
        const oversBowled = (player.oversBowled || 0).toFixed(1);
        const maxOvers = MATCH_DATA.match_type === 'T20' ? 4 : 10;
        const remainingOvers = (maxOvers - (player.oversBowled || 0)).toFixed(1);
        option.textContent = `${player.name} (${player.bowling_type}, Skill: ${player.bowling_skill}, Overs: ${oversBowled}/${maxOvers})`;
        bowlerSelect.appendChild(option);
    });
}

function updateNewBowlerPreview() {
    const bowlerId = document.getElementById('new-bowler-select').value;
    const previewDiv = document.getElementById('player-preview');
    
    if (bowlerId) {
        const bowler = matchState.bowlingTeam.players.find(p => p.id == bowlerId);
        const oversBowled = (bowler.oversBowled || 0).toFixed(1);
        const maxOvers = MATCH_DATA.match_type === 'T20' ? 4 : 10;
        const remainingOvers = (maxOvers - (bowler.oversBowled || 0)).toFixed(1);
        
        previewDiv.innerHTML = `
            <h4>üìä New Bowler Preview</h4>
            <div class="player-preview-item">
                <strong>‚öæ New Bowler:</strong> ${bowler.name}<br>
                Type: ${bowler.bowling_type} | Skill: ${bowler.bowling_skill}<br>
                Overs Bowled: ${oversBowled}/${maxOvers} | Remaining: ${remainingOvers}
            </div>
        `;
    } else {
        previewDiv.innerHTML = '<h4>üìä New Bowler Preview</h4><p>Select a bowler to see their stats</p>';
    }
}

function confirmNewBowler() {
    const bowlerId = document.getElementById('new-bowler-select').value;
    
    if (!bowlerId) {
        showNotification('Please select a new bowler', 'error');
        return;
    }
    
    // Get the selected bowler
    const newBowler = matchState.bowlingTeam.players.find(p => p.id == bowlerId);
    
    // Set as new bowler
    matchState.currentBowler = newBowler;
    
    // Bowler stats are managed by scorecardManager - no need to manually initialize
    // The scorecardManager.initializeInnings() already sets up all player stats
    
    // Close modal
    closeNewBowlerModal();
    
    // Update display
    document.getElementById('bowler-name').textContent = matchState.currentBowler.name;
    
    // Show confirmation
    showNotification(`${matchState.currentBowler.name} to bowl`, 'success');
    
    // Update ticker
    updateTicker(`‚öæ ${matchState.currentBowler.name} will bowl the next over ‚Ä¢ ${matchState.currentBowler.bowling_type} bowling`);
}

function closeNewBowlerModal() {
    const modal = document.getElementById('player-modal');
    modal.style.display = 'none';
    
    // Remove event listener
    const bowlerSelect = document.getElementById('new-bowler-select');
    if (bowlerSelect) {
        bowlerSelect.removeEventListener('change', updateNewBowlerPreview);
    }
    
    // Reset modal to original opening players selection content
    resetModalToOriginal();
}

function checkInningsCompletion() {
    const totalBalls = matchState.ballsFaced || 0;
    const maxBalls = MATCH_DATA.max_overs * 6;

    if (totalBalls >= maxBalls || matchState.wicketsLost >= 10) {
        // Overs completed or all wickets fallen
        endInnings();
        return; // Exit early to prevent further processing
    }
    
    if (matchState.currentInnings > 1) {
        // Second innings - end when target reached, overs complete, or all wickets fall
        if (matchState.totalRuns >= matchState.target) {
            // Target achieved - batting team wins
            endInnings();
            return; // Exit early to prevent further processing
        }
    }
}

function endMatch() {
    // Determine match result
    let result;
    if (matchState.currentInnings === 2) {
        if (matchState.totalRuns >= matchState.target) {
            result = `${matchState.battingTeam.short_name} won by ${10 - matchState.wicketsLost} wickets`;
        } else {
            result = `${matchState.bowlingTeam.short_name} won by ${matchState.firstInningsScore - matchState.totalRuns} runs`;
        }
    }
    
    // Store the result for display
    matchState.matchResult = result;
    
    showNotification(`Match completed! ${result}`, 'success');
    updateTicker(`üèè Match Over ‚Ä¢ ${result}`);
    
    // Update projection info to show result
    document.getElementById('projection-info').textContent = `üèÜ ${result}`;
    
    // Disable all simulation controls
    document.getElementById('next-ball-btn').disabled = true;
    document.getElementById('auto-sim-btn').disabled = true;
    
    // Update match status
    updateMatchStatus('completed');
}

function endInnings() {
    if (matchState.currentInnings === 1) {
        // First innings completed
        matchState.firstInningsScore = matchState.totalRuns;
        matchState.target = matchState.firstInningsScore + 1;
        
        showNotification('First innings completed!', 'success');
        updateTicker(`üèè First innings ends ‚Ä¢ ${matchState.battingTeam.short_name}: ${matchState.totalRuns}/${matchState.wicketsLost} ‚Ä¢ Target: ${matchState.target}`);
        
        // Switch teams for second innings
        matchState.secondInningsBattingTeam = matchState.bowlingTeam;
        matchState.secondInningsBowlingTeam = matchState.battingTeam;
        
        // Start second innings
        setTimeout(() => {
            startSecondInnings();
        }, 2000);
    } else {
        // Second innings completed - match over
        showNotification('Match completed!', 'success');
        endMatch();
    }
}

function startSecondInnings() {
    // Update match state for second innings
    matchState.currentInnings = 2;
    matchState.battingTeam = matchState.secondInningsBattingTeam;
    matchState.bowlingTeam = matchState.secondInningsBowlingTeam;
    
    // Reset match stats for second innings
    matchState.totalRuns = 0;
    matchState.wicketsLost = 0;
    matchState.ballsFaced = 0;
    matchState.currentBalls = 0;
    matchState.secondInningsBattingOrderPlayers = []; // Initialize second innings batting order
    matchState.battingOrderPlayers = matchState.secondInningsBattingOrderPlayers; // Point to second innings array
    matchState.wicketkeeper = matchState.bowlingTeam.players.find(p => p.is_wicketkeeper);
    
    // Initialize stats tracking for second innings
    matchState.scorecardManager.initializeInnings(2, matchState.battingTeam, matchState.bowlingTeam);
    
    // Update display for second innings
    updateMatchDisplay();
    
    // Show second innings controls
    document.getElementById('live-controls').style.display = 'block';
    document.getElementById('player-status').style.display = 'grid';
    document.getElementById('over-display').style.display = 'block';
    
    // Update status
    updateMatchStatus('live');
    
    // Prompt for opening batsmen and bowler selection for second innings
    selectOpeningPlayers();
    
    showNotification('Second innings starting!', 'info');
    updateTicker(`üèè Second innings begins ‚Ä¢ ${matchState.battingTeam.short_name} need ${matchState.target} to win`);
}

function autoSimulate() {
    if (matchState.isAutoSimulating) return;
    
    matchState.isAutoSimulating = true;
    document.getElementById('auto-sim-btn').style.display = 'none';
    document.getElementById('pause-btn').style.display = 'inline-block';
    
    matchState.autoInterval = setInterval(() => {
        simulateDelivery();
    }, 1500); // Simulate a ball every 1.5 seconds
}

function pauseSimulation() {
    matchState.isAutoSimulating = false;
    document.getElementById('auto-sim-btn').style.display = 'inline-block';
    document.getElementById('pause-btn').style.display = 'none';
    
    if (matchState.autoInterval) {
        clearInterval(matchState.autoInterval);
        matchState.autoInterval = null;
    }
}

function updateMatchStatus(status) {
    const statusIndicator = document.getElementById('status-indicator');
    const statusText = document.getElementById('match-status');
    
    statusIndicator.className = `status-indicator status-${status}`;
    statusText.textContent = status.charAt(0).toUpperCase() + status.slice(1);
}

function updateTicker(message) {
    document.getElementById('ticker-content').textContent = message;
}

function updateMatchDisplay() {
    // Initialize default values if match just started
    if (!matchState.totalRuns) {
        matchState.totalRuns = 0;
        matchState.wicketsLost = 0;
        matchState.ballsFaced = 0;
    }
    
    if (matchState.currentInnings === 1) {
        // First innings
        document.getElementById('team1-name').textContent = matchState.battingTeam ? matchState.battingTeam.short_name : MATCH_DATA.team1.short_name;
        document.getElementById('team2-name').textContent = matchState.bowlingTeam ? matchState.bowlingTeam.short_name : MATCH_DATA.team2.short_name;
        
        // Update scores for first innings
        document.getElementById('team1-score').textContent = `${matchState.totalRuns}/${matchState.wicketsLost}`;
        document.getElementById('team2-score').textContent = '-';
        document.getElementById('team2-rr').textContent = 'Target: -';
        
        const runRate = (((matchState.totalRuns || 0) * 6) / (matchState.currentBalls || 1)).toFixed(2);
        document.getElementById('team1-rr').textContent = `RR: ${runRate}`;
        
        // Show projected score for first innings
        const projectedScore = Math.round(runRate * MATCH_DATA.max_overs);
        document.getElementById('projection-info').textContent = `Projected score: ${projectedScore}`;
    } else {
        // Second innings
        document.getElementById('team1-name').textContent = matchState.battingTeam.short_name;
        document.getElementById('team2-name').textContent = matchState.bowlingTeam.short_name;
        
        // Update scores for second innings
        document.getElementById('team1-score').textContent = `${matchState.totalRuns}/${matchState.wicketsLost}`;
        document.getElementById('team2-score').textContent = `${matchState.firstInningsScore}/10`;
        
        // Calculate run rate and required run rate
        const runRate = (((matchState.totalRuns || 0) * 6) / (matchState.currentBalls || 1)).toFixed(2);
        const remainingRuns = matchState.target - matchState.totalRuns;
        const remainingBalls = (MATCH_DATA.max_overs * 6) - matchState.currentBalls;
        const requiredRunRate = remainingBalls > 0 ? (remainingRuns * 6 / remainingBalls).toFixed(2) : '0.00';
        
        document.getElementById('team1-rr').textContent = `RR: ${runRate} | RRR: ${requiredRunRate}`;
        document.getElementById('team2-rr').textContent = `Target: ${matchState.target}`;
        
        // Show runs needed for second innings
        document.getElementById('projection-info').textContent = `Need ${remainingRuns} runs from ${remainingBalls} balls`;
    }
    
    // Check if match is completed and show result
    if (matchState.matchResult) {
        document.getElementById('projection-info').textContent = `üèÜ ${matchState.matchResult}`;
    }
    
    // Initialize batting and bowling lists
    updateBattingCard();
    updateBowlingCard();
}

function updateBattingCard() {
    const battingList = document.getElementById('batting-list');
    if (!matchState.battingTeam) return;
    
    battingList.innerHTML = '';
    
    // Add fixed header row
    const headerRow = document.createElement('div');
    headerRow.className = 'batting-header';
    headerRow.innerHTML = `
        <div>Player</div>
        <div>Score</div>
        <div>SR</div>
        <div>4s/6s</div>
    `;
    battingList.appendChild(headerRow);
    
    // Show only players who have already batted (in batting order)
    matchState.battingOrderPlayers.forEach(player => {
        // Get stats for this player from the current innings
        const battingScore = matchState.scorecardManager.getBattingScore(matchState.currentInnings, player.id);
        if (!battingScore || battingScore.ballsFaced === 0) return; // Skip if not batted yet
        
        const row = document.createElement('div');
        row.className = 'batting-row';
        
        // Check if this player is currently batting
        if (player.id === matchState.striker?.id || player.id === matchState.nonStriker?.id) {
            row.classList.add('current', 'not-out');
        } else if (!battingScore.notOut) {
            row.classList.add('out');
        } else {
            row.classList.add('not-out');
        }
        
        const scorecardRow = battingScore.getScorecardRow();
        
        row.innerHTML = `
            <div>${player.name}${player.is_captain ? ' (c)' : ''}${player.is_wicketkeeper ? ' (wk)' : ''}</div>
            <div>${scorecardRow.score}</div>
            <div>${scorecardRow.strikeRate}</div>
            <div>${scorecardRow.fours}/${scorecardRow.sixes}</div>
        `;
        
        battingList.appendChild(row);
    });
}

function updateBowlingCard() {
    const bowlingList = document.getElementById('bowling-list');
    if (!matchState.bowlingTeam) return;
    
    bowlingList.innerHTML = '';
    
    // Add fixed header row
    const headerRow = document.createElement('div');
    headerRow.className = 'bowling-header';
    headerRow.innerHTML = `
        <div>Bowler</div>
        <div>Overs</div>
        <div>Runs</div>
        <div>Wickets</div>
        <div>Economy</div>
    `;
    bowlingList.appendChild(headerRow);
    
    // Get current innings bowling stats
    const currentInningsStats = matchState.scorecardManager.getInningsScorecard(matchState.currentInnings);
    
    // Show bowlers who have bowled in current innings
    currentInningsStats.bowling
        .filter(bowlingFigures => bowlingFigures.deliveries > 0 || bowlingFigures.playerName === matchState.currentBowler?.name)
        .forEach(bowlingFigures => {
            const row = document.createElement('div');
            row.className = 'bowling-row';
            
            const scorecardRow = bowlingFigures.getScorecardRow();
            
            row.innerHTML = `
                <div>${scorecardRow.playerName}</div>
                <div>${scorecardRow.overs}</div>
                <div>${scorecardRow.runs}</div>
                <div>${scorecardRow.wickets}</div>
                <div>${scorecardRow.economy}</div>
            `;
            
            bowlingList.appendChild(row);
        });
}

// Initialize match state based on current status
if (MATCH_DATA.status === 'first_innings' || MATCH_DATA.status === 'second_innings') {
    // Match is already in progress, load current state
    setTimeout(() => {
        document.getElementById('live-controls').style.display = 'block';
        document.getElementById('player-status').style.display = 'grid';
        document.getElementById('over-display').style.display = 'block';
        updateMatchStatus('live');
        selectOpeningPlayers();
    }, 1000);
}
</script>


<style>
    /* Use your beautiful concept 1 styles - Midnight Blue Elegance */
    .match-container {
        background: linear-gradient(135deg, #0c1445 0%, #1a237e 50%, #283593 100%);
        border-radius: 20px;
        overflow: hidden;
        border: 2px solid #1976d2;
        box-shadow: 0 20px 40px rgba(0,0,0,0.3);
        min-height: 600px;
        position: relative;
    }

    .top-banner {
        background: linear-gradient(90deg, rgba(0,0,0,0.9), rgba(25,118,210,0.3), rgba(0,0,0,0.9));
        border-bottom: 3px solid #2196f3;
        color: #e3f2fd;
        min-height: 80px;
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 20px 30px;
        font-size: 1rem;
        font-weight: bold;
    }

    .team-section {
        display: flex;
        flex-direction: column;
        align-items: center;
        min-width: 200px;
    }

    .team-info {
        display: flex;
        align-items: center;
        gap: 20px;
    }

    .team-name {
        font-size: 1.3rem;
        font-weight: bold;
    }

    .team-score {
        font-size: 1.8rem;
        font-weight: bold;
    }

    .run-rate {
        font-size: 0.9rem;
        opacity: 0.9;
    }

    .projection-info {
        font-size: 0.8rem;
        opacity: 0.8;
        color: #90caf9;
        margin-top: 2px;
        display: block;
        width: 100%;
        text-align: center;
    }

    .match-info {
        text-align: center;
        font-size: 0.9rem;
    }

    .main-content {
        display: grid;
        grid-template-columns: 2fr 1fr;
        gap: 20px;
        padding: 20px;
        min-height: 480px;
    }

    .center-area {
        display: flex;
        flex-direction: column;
        gap: 20px;
    }

    .player-status {
        background: rgba(0,0,0,0.6);
        border: 1px solid rgba(33,150,243,0.3);
        box-shadow: 0 0 20px rgba(33,150,243,0.1);
        border-radius: 15px;
        padding: 20px;
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 20px;
    }

    .batsman {
        text-align: center;
        position: relative;
        padding: 15px;
        border-radius: 10px;
        transition: all 0.3s ease;
    }

    .batsman.on-strike {
        background: rgba(255,215,0,0.2);
        border: 2px solid rgba(255,215,0,0.4);
    }

    .batsman.on-strike::before {
        content: "‚òÖ";
        position: absolute;
        top: -5px;
        right: -5px;
        color: #ffd700;
        font-size: 1.2rem;
        animation: sparkle 2s ease-in-out infinite;
    }

    @keyframes sparkle {
        0%, 100% { opacity: 1; transform: scale(1); }
        50% { opacity: 0.5; transform: scale(1.2); }
    }

    .player-name {
        font-size: 1.2rem;
        font-weight: bold;
        margin-bottom: 8px;
        color: #e3f2fd;
    }

    .player-stats {
        font-size: 0.9rem;
        opacity: 0.9;
        color: #bbdefb;
    }

    .over-display {
        background: rgba(0,0,0,0.6);
        border: 1px solid rgba(33,150,243,0.3);
        box-shadow: 0 0 20px rgba(33,150,243,0.1);
        border-radius: 15px;
        padding: 20px;
        flex: 1;
    }

    .current-over-info {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 15px;
    }

    .bowler-name {
        font-size: 1.1rem;
        font-weight: bold;
        color: #e3f2fd;
    }

    .over-number {
        font-size: 1rem;
        opacity: 0.8;
        color: #90caf9;
    }

    .balls-container {
        display: flex;
        gap: 8px;
        align-items: center;
        flex-wrap: wrap;
        min-height: 40px;
    }

    .ball {
        width: 35px;
        height: 35px;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 0.9rem;
        font-weight: bold;
        animation: ballAppear 0.5s ease-out;
        box-shadow: 0 2px 8px rgba(0,0,0,0.3);
    }

    @keyframes ballAppear {
        0% { transform: scale(0) rotate(180deg); opacity: 0; }
        100% { transform: scale(1) rotate(0deg); opacity: 1; }
    }

    .ball.dot { background: #6c757d; color: white; }
    .ball.runs { background: #007bff; color: white; }
    .ball.four { background: #28a745; color: white; }
    .ball.six { background: #dc3545; color: white; }
    .ball.wicket { background: #6f42c1; color: white; }
    .ball.wide { background: #ffc107; color: black; }
    .ball.noball { background: #fd7e14; color: white; }

    .scorecards {
        display: flex;
        flex-direction: column;
        gap: 20px;
    }

    .scorecard {
        background: rgba(0,0,0,0.6);
        border: 1px solid rgba(33,150,243,0.3);
        box-shadow: 0 0 20px rgba(33,150,243,0.1);
        border-radius: 15px;
        padding: 20px;
    }

    .scorecard-title {
        font-size: 1.1rem;
        font-weight: bold;
        margin-bottom: 15px;
        text-align: center;
        color: #2196f3;
    }

    .batting-list, .bowling-list {
        display: flex;
        flex-direction: column;
        gap: 8px;
        max-height: 200px;
        overflow-y: auto;
        position: relative;
    }
    
    .batting-header, .bowling-header {
        display: grid;
        grid-template-columns: 2fr 1fr 1fr 1fr;
        padding: 8px;
        border-radius: 8px;
        font-size: 0.9rem;
        font-weight: bold;
        background: rgba(33,150,243,0.2);
        border: 1px solid rgba(33,150,243,0.3);
        color: #2196f3;
        position: sticky;
        top: 0;
        z-index: 10;
        backdrop-filter: blur(5px);
    }
    
    /* Add a solid background behind the translucent header to block content */
    .batting-header::before, .bowling-header::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0,0,0,0.8);
        border-radius: 8px;
        z-index: -1;
    }
    
    .bowling-header {
        grid-template-columns: 2fr 1fr 1fr 1fr 1fr;
    }
    
    /* Full Scorecard Styling */
    .full-scorecard {
        max-width: 100%;
        color: #e3f2fd;
    }
    
    /* Scorecard Tabs Styling */
    .scorecard-tabs {
        display: flex;
        justify-content: center;
        gap: 10px;
        margin-bottom: 25px;
        padding: 15px;
        background: rgba(0,0,0,0.4);
        border-radius: 10px;
        border: 1px solid rgba(33,150,243,0.2);
    }
    
    .tab-btn {
        padding: 12px 24px;
        background: rgba(33,150,243,0.2);
        border: 1px solid rgba(33,150,243,0.3);
        border-radius: 8px;
        color: #e3f2fd;
        cursor: pointer;
        font-size: 1rem;
        font-weight: bold;
        transition: all 0.3s ease;
    }
    
    .tab-btn:hover {
        background: rgba(33,150,243,0.4);
        transform: translateY(-2px);
        box-shadow: 0 5px 15px rgba(33,150,243,0.3);
    }
    
    .tab-btn.active {
        background: rgba(33,150,243,0.6);
        border-color: #2196f3;
        color: #fff;
        box-shadow: 0 0 20px rgba(33,150,243,0.5);
    }
    
    .scorecard-header-container {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 25px;
        padding-bottom: 15px;
        border-bottom: 2px solid rgba(33,150,243,0.3);
    }
    
    .scorecard-header-container h2 {
        color: #2196f3;
        font-size: 1.8rem;
        text-shadow: 0 0 10px rgba(33,150,243,0.5);
        margin: 0;
    }
    
    .close-btn {
        position: absolute;
        top: 15px;
        right: 15px;
        padding: 8px 12px;
        font-size: 1rem;
        border-radius: 50%;
        width: 40px;
        height: 40px;
        display: flex;
        align-items: center;
        justify-content: center;
    }
    
    .full-scorecard h2 {
        text-align: center;
        color: #2196f3;
        margin-bottom: 25px;
        font-size: 1.8rem;
        text-shadow: 0 0 10px rgba(33,150,243,0.5);
    }
    
    .full-scorecard h3 {
        color: #ffd700;
        margin: 25px 0 15px 0;
        font-size: 1.4rem;
        border-bottom: 2px solid rgba(255,215,0,0.3);
        padding-bottom: 8px;
    }
    
    .full-scorecard h4 {
        color: #4caf50;
        margin: 20px 0 15px 0;
        font-size: 1.2rem;
    }
    
    .innings-section {
        margin-bottom: 30px;
        padding: 20px;
        background: rgba(0,0,0,0.4);
        border-radius: 15px;
        border: 1px solid rgba(33,150,243,0.2);
    }
    
    .scorecard-table {
        background: rgba(0,0,0,0.6);
        border-radius: 10px;
        overflow: hidden;
        border: 1px solid rgba(33,150,243,0.3);
        margin-bottom: 20px;
    }
    
    .scorecard-header {
        display: grid;
        grid-template-columns: 2fr 1.5fr 1fr 1fr 1fr;
        padding: 12px 15px;
        background: rgba(33,150,243,0.2);
        border-bottom: 2px solid rgba(33,150,243,0.3);
        font-weight: bold;
        color: #2196f3;
        font-size: 0.95rem;
    }
    
    .scorecard-row {
        display: grid;
        grid-template-columns: 2fr 1.5fr 1fr 1fr 1fr;
        padding: 10px 15px;
        border-bottom: 1px solid rgba(33,150,243,0.1);
        transition: background 0.3s ease;
        font-size: 0.9rem;
    }
    
    .scorecard-row:hover {
        background: rgba(33,150,243,0.1);
    }
    
    .scorecard-row:last-child {
        border-bottom: none;
    }
    
    /* Special styling for extras and total rows */
    .extras-row {
        background: rgba(255,193,7,0.1);
        border-top: 2px solid rgba(255,193,7,0.3);
        font-weight: bold;
    }
    
    .total-row {
        background: rgba(76,175,80,0.1);
        border-top: 2px solid rgba(76,175,80,0.3);
        font-weight: bold;
        color: #4caf50;
    }
    
    .total-row strong {
        color: #4caf50;
        font-size: 1.1rem;
    }
    
    /* Current batsman highlighting */
    .current-batsman {
        background: rgba(255,215,0,0.15);
        border: 1px solid rgba(255,215,0,0.4);
        font-weight: bold;
    }
    
    .current-batsman::before {
        content: "‚òÖ";
        position: absolute;
        left: 10px;
        color: #ffd700;
        font-size: 1.2rem;
    }
    
    /* Not batted yet styling */
    .not-batted {
        background: rgba(128,128,128,0.1);
        color: #888;
        font-style: italic;
    }
    
    /* Bowling table has different column layout */
    .bowling-table .scorecard-header,
    .bowling-table .scorecard-row {
        grid-template-columns: 2fr 1fr 1fr 1fr 1fr;
    }
    
    /* Batting table column layout */
    .batting-table .scorecard-header,
    .batting-table .scorecard-row {
        grid-template-columns: 2fr 1.5fr 1fr 1fr 1fr;
    }
    
    /* Responsive adjustments */
    @media (max-width: 768px) {
        .scorecard-header,
        .scorecard-row {
            grid-template-columns: 1.5fr 1fr 1fr 1fr;
            font-size: 0.8rem;
            padding: 8px 10px;
        }
        
        .full-scorecard h2 {
            font-size: 1.5rem;
        }
        
        .full-scorecard h3 {
            font-size: 1.2rem;
        }
    }

    .batting-row, .bowling-row {
        display: grid;
        grid-template-columns: 2fr 1fr 1fr 1fr;
        padding: 8px;
        border-radius: 8px;
        font-size: 0.9rem;
        transition: background 0.3s ease;
        color: #e3f2fd;
    }

    .batting-row:hover, .bowling-row:hover {
        background: rgba(33,150,243,0.1);
    }

    .bowling-row {
        grid-template-columns: 2fr 1fr 1fr 1fr 1fr;
    }

    .batting-row.current {
        background: rgba(255,215,0,0.1);
        border: 1px solid rgba(255,215,0,0.3);
    }

    .batting-row.not-out {
        color: #4caf50;
    }

    .batting-row.out {
        color: #f44336;
        opacity: 0.7;
    }

    .bottom-ticker {
        position: absolute;
        bottom: 0;
        left: 0;
        right: 0;
        height: 40px;
        background: linear-gradient(90deg, #1565c0, #1976d2);
        color: white;
        display: flex;
        align-items: center;
        padding: 0 20px;
        font-size: 0.9rem;
        overflow: hidden;
        white-space: nowrap;
    }

    .ticker-content {
        animation: tickerScroll 20s linear infinite;
    }

    @keyframes tickerScroll {
        0% { transform: translateX(100%); }
        100% { transform: translateX(-100%); }
    }

    .match-controls {
        background: rgba(33,150,243,0.1);
        border: 1px solid rgba(33,150,243,0.3);
        border-radius: 15px;
        padding: 20px;
        margin-top: 20px;
        text-align: center;
    }

    .control-section {
        margin-bottom: 20px;
    }

    .control-title {
        font-size: 1.1rem;
        font-weight: bold;
        margin-bottom: 10px;
        color: #2196f3;
    }

    .btn {
        padding: 12px 20px;
        border: none;
        border-radius: 8px;
        cursor: pointer;
        font-size: 1rem;
        margin: 5px;
        transition: all 0.3s ease;
    }

    .btn-primary {
        background: linear-gradient(45deg, #1565c0, #2196f3);
        color: white;
    }

    .btn-primary:hover {
        transform: translateY(-2px);
        box-shadow: 0 5px 15px rgba(33,150,243,0.3);
    }

    .btn-success {
        background: linear-gradient(45deg, #2e7d32, #4caf50);
        color: white;
    }

    .btn-warning {
        background: linear-gradient(45deg, #f57c00, #ff9800);
        color: white;
    }

    .btn-danger {
        background: linear-gradient(45deg, #c62828, #f44336);
        color: white;
    }

    .btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
    }

    .toss-section {
        background: rgba(255,215,0,0.1);
        border: 2px solid rgba(255,215,0,0.3);
        border-radius: 15px;
        padding: 25px;
        text-align: center;
        margin-bottom: 20px;
    }

    .toss-options {
        display: flex;
        gap: 15px;
        justify-content: center;
        margin: 20px 0;
    }

    .radio-group {
        display: flex;
        align-items: center;
        gap: 8px;
        padding: 10px 15px;
        background: rgba(0,0,0,0.3);
        border-radius: 8px;
        cursor: pointer;
        transition: all 0.3s ease;
    }

    .radio-group:hover {
        background: rgba(255,215,0,0.1);
    }

    .modal {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0,0,0,0.8);
        z-index: 1000;
    }

    .modal-content {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: #1a1a1a;
        border-radius: 15px;
        padding: 30px;
        max-width: 1200px;
        width: 95%;
        max-height: 90vh;
        overflow-y: auto;
        text-align: center;
        box-sizing: border-box;
    }

    .player-select {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
        gap: 10px;
        margin: 20px 0;
    }

    .player-option {
        padding: 10px;
        background: rgba(33,150,243,0.2);
        border: 1px solid rgba(33,150,243,0.3);
        border-radius: 8px;
        cursor: pointer;
        transition: all 0.3s ease;
    }

    .player-option:hover {
        background: rgba(33,150,243,0.4);
        transform: translateY(-2px);
    }

    .status-indicator {
        display: inline-block;
        width: 12px;
        height: 12px;
        border-radius: 50%;
        margin-right: 8px;
    }

    .status-setup { background: #ffc107; }
    .status-toss { background: #ff9800; }
    .status-live { background: #4caf50; animation: pulse 2s ease-in-out infinite; }
    .status-completed { background: #9e9e9e; }

    @keyframes pulse {
        0%, 100% { opacity: 1; }
        50% { opacity: 0.5; }
    }

    /* Player Selection Modal Styles */
    .selection-section {
        margin-bottom: 25px;
        padding: 15px;
        background: rgba(0,0,0,0.3);
        border-radius: 10px;
        border: 1px solid rgba(33,150,243,0.2);
    }

    .selection-section h4 {
        margin-bottom: 15px;
        color: #2196f3;
        font-size: 1.1rem;
    }

    .player-grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 20px;
        width: 100%;
        max-width: 100%;
    }

    .player-column {
        display: flex;
        flex-direction: column;
        gap: 8px;
    }

    .player-column label {
        font-weight: bold;
        color: #e3f2fd;
        font-size: 0.9rem;
    }

    .player-select-dropdown {
        padding: 10px;
        background: rgba(0,0,0,0.5);
        border: 1px solid rgba(33,150,243,0.3);
        border-radius: 6px;
        color: #fff;
        font-size: 0.9rem;
        cursor: pointer;
        width: 100%;
        max-width: 100%;
        box-sizing: border-box;
        overflow: hidden;
        text-overflow: ellipsis;
    }

    .player-select-dropdown:focus {
        outline: none;
        border-color: #2196f3;
        box-shadow: 0 0 10px rgba(33,150,243,0.3);
    }

    .player-select-dropdown option {
        background: #1a1a1a;
        color: #fff;
        padding: 8px;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
    }

    .player-preview {
        margin: 20px 0;
        padding: 15px;
        background: rgba(0,0,0,0.4);
        border-radius: 10px;
        border: 1px solid rgba(33,150,243,0.2);
    }

    .player-preview h4 {
        margin-bottom: 15px;
        color: #4caf50;
        text-align: center;
    }

    .player-preview-item {
        margin-bottom: 12px;
        padding: 10px;
        background: rgba(33,150,243,0.1);
        border-radius: 6px;
        border-left: 3px solid #2196f3;
    }

    .modal-actions {
        display: flex;
        gap: 15px;
        justify-content: center;
        margin-top: 25px;
    }

    .btn-secondary {
        background: linear-gradient(45deg, #6c757d, #495057);
        color: white;
    }

    .btn-secondary:hover {
        transform: translateY(-2px);
        box-shadow: 0 5px 15px rgba(108,117,125,0.3);
    }
</style>
{% endblock %}

{% block content %}
<div class="match-container" id="match-container">
    <!-- Top Banner with Match Info -->
    <div class="top-banner">
        <div class="team-info">
            <div class="team-name" id="team1-name">{{ match.team1.short_name }}</div>
            <div class="team-score" id="team1-score">0/0</div>
            <div class="run-rate" id="team1-rr">RR: 0.00</div>
        </div>
        <div class="match-info">
            <div id="match-type">{{ match.match_type }} Match</div>
            <div id="match-overs">0.0/{{ {'T20': 20, 'ODI': 50}[match.match_type] }} overs</div>
            <div>
                <span class="status-indicator status-{{ match.status }}" id="status-indicator"></span>
                <span id="match-status">{{ match.status.title() }}</span>
            </div>
            <div class="projection-info" id="projection-info"></div>
        </div>
        <div class="team-section">
            <div class="team-info">
                <div class="run-rate" id="team2-rr">Target: -</div>
                <div class="team-score" id="team2-score">-</div>
                <div class="team-name" id="team2-name">{{ match.team2.short_name }}</div>
            </div>
        </div>
    </div>

    <!-- Main Content Area -->
    <div class="main-content">
        <div class="center-area">
            <!-- Current Batsmen -->
            <div class="player-status" id="player-status" style="display: none;">
                <div class="batsman" id="striker">
                    <div class="player-name" id="striker-name">-</div>
                    <div class="player-stats" id="striker-stats">0* (0) | SR: 0.00<br>4s: 0 ‚Ä¢ 6s: 0</div>
                </div>
                <div class="batsman" id="non-striker">
                    <div class="player-name" id="non-striker-name">-</div>
                    <div class="player-stats" id="non-striker-stats">0* (0) | SR: 0.00<br>4s: 0 ‚Ä¢ 6s: 0</div>
                </div>
            </div>

            <!-- Current Over Display -->
            <div class="over-display" id="over-display" style="display: none;">
                <div class="current-over-info">
                    <div class="bowler-name" id="bowler-name">-</div>
                    <div class="over-number" id="over-number">Over 0.0</div>
                </div>
                <div class="balls-container" id="balls-container">
                    <!-- Balls will be added dynamically -->
                </div>
            </div>
        </div>

        <!-- Scorecards -->
        <div class="scorecards">
            <div class="scorecard">
                <div class="scorecard-title">üèè Batting Card</div>
                <div class="batting-list" id="batting-list">
                    <!-- Batting stats will be populated here -->
                </div>
            </div>

            <div class="scorecard">
                <div class="scorecard-title">‚öæ Bowling Figures</div>
                <div class="bowling-list" id="bowling-list">
                    <!-- Bowling stats will be populated here -->
                </div>
            </div>
        </div>
    </div>

    <!-- Bottom Ticker -->
    <div class="bottom-ticker">
        <div class="ticker-content" id="ticker-content">
            üèè Welcome to the Cricket Simulator ‚Ä¢ Match between {{ match.team1.full_name }} and {{ match.team2.full_name }}
        </div>
    </div>
</div>

<!-- Match Controls -->
<div class="match-controls" id="match-controls">
    <!-- Toss Section -->
    <div class="toss-section" id="toss-section" style="display: none;">
        <div class="control-title">ü™ô Toss Time!</div>
        <p>{{ match.team1.full_name }} to call heads or tails</p>
        <div class="toss-options">
            <label class="radio-group">
                <input type="radio" name="toss-call" value="heads" checked>
                <span>Heads</span>
            </label>
            <label class="radio-group">
                <input type="radio" name="toss-call" value="tails">
                <span>Tails</span>
            </label>
        </div>
        <button class="btn btn-warning" onclick="conductToss()">üé≤ Flip Coin</button>
    </div>

    <!-- Toss Decision Section -->
    <div class="control-section" id="toss-decision-section" style="display: none;">
        <div class="control-title">üèè Toss Winner Decision</div>
        <div id="toss-result-text"></div>
        <div style="margin: 20px 0;">
            <button class="btn btn-primary" onclick="makeTossDecision('bat')">üèè Bat First</button>
            <button class="btn btn-success" onclick="makeTossDecision('bowl')">‚öæ Bowl First</button>
        </div>
    </div>

    <!-- Match Start Section -->
    <div class="control-section" id="start-section" style="display: none;">
        <div class="control-title">üöÄ Ready to Start</div>
        <div id="batting-order-text"></div>
        <button class="btn btn-success" onclick="startMatch()">‚ñ∂Ô∏è Start Match</button>
    </div>

    <!-- Live Match Controls -->
    <div class="control-section" id="live-controls" style="display: none;">
        <div class="control-title">‚ö° Live Match</div>
        <button class="btn btn-primary" onclick="simulateDelivery()" id="next-ball-btn">üéØ Next Ball</button>
        <button class="btn btn-warning" onclick="autoSimulate()" id="auto-sim-btn">‚ö° Auto Simulate</button>
        <button class="btn btn-danger" onclick="pauseSimulation()" id="pause-btn" style="display: none;">‚è∏Ô∏è Pause</button>
        <button class="btn btn-success" onclick="showFullScorecard()" id="scorecard-btn">üìä Full Scorecard</button>
    </div>
</div>

<!-- Player Selection Modal -->
<div class="modal" id="player-modal">
    <div class="modal-content">
        <h3 id="modal-title">Select Opening Players</h3>
        
        <!-- Batsmen Selection -->
        <div class="selection-section">
            <h4>üèè Select Opening Batsmen</h4>
            <div class="player-grid">
                <div class="player-column">
                    <label>Striker (on strike):</label>
                    <select id="striker-select" class="player-select-dropdown">
                        <option value="">Choose striker...</option>
                    </select>
                </div>
                <div class="player-column">
                    <label>Non-striker:</label>
                    <select id="non-striker-select" class="player-select-dropdown">
                        <option value="">Choose non-striker...</option>
                    </select>
                </div>
            </div>
        </div>
        
        <!-- Bowler Selection -->
        <div class="selection-section">
            <h4>‚öæ Select Opening Bowler</h4>
            <div class="player-grid">
                <div class="player-column">
                    <label>Opening Bowler:</label>
                    <select id="bowler-select" class="player-select-dropdown">
                        <option value="">Choose bowler...</option>
                    </select>
                </div>
            </div>
        </div>
        
        <!-- Player Stats Preview -->
        <div class="player-preview" id="player-preview">
            <!-- Player stats will be shown here -->
        </div>
        
        <!-- Action Buttons -->
        <div class="modal-actions">
            <button class="btn btn-primary" onclick="confirmPlayerSelection()">‚úÖ Confirm Selection</button>
            <button class="btn btn-secondary" onclick="closePlayerModal()">‚ùå Cancel</button>
        </div>
    </div>
</div>

<!-- Match Data (Hidden, for JavaScript) -->
<script>
    const MATCH_DATA = {
        match_id: "{{ match.match_id }}",
        team1: JSON.parse('{{ match.team1.to_dict() | tojson | safe }}'),
        team2: JSON.parse('{{ match.team2.to_dict() | tojson | safe }}'),
        match_type: "{{ match.match_type }}",
        status: "{{ match.status }}",
        max_overs: {{ {'T20': 20, 'ODI': 50}[match.match_type] }}
    };
    
    // Event Animation System
    function showEventAnimation(title, eventType, subtitle) {
        // Create animation container
        const animationContainer = document.createElement('div');
        animationContainer.className = `event-animation ${eventType}-animation`;
        
        // Create animation content
        animationContainer.innerHTML = `
            <div class="animation-content">
                <div class="animation-title">${title}</div>
                <div class="animation-subtitle">${subtitle}</div>
            </div>
        `;
        
        // Add to match container
        const matchContainer = document.getElementById('match-container');
        matchContainer.appendChild(animationContainer);
        
        // Trigger animation
        setTimeout(() => {
            animationContainer.classList.add('animate');
        }, 100);
        
        // Remove animation after completion
        setTimeout(() => {
            animationContainer.classList.add('fade-out');
            setTimeout(() => {
                if (animationContainer.parentNode) {
                    animationContainer.parentNode.removeChild(animationContainer);
                }
            }, 500);
        }, 2000);
    }
    
    // Full Scorecard Display
    function showFullScorecard() {
        const fullScorecard = matchState.scorecardManager.getFullMatchScorecard();
        
        let scorecardHTML = '<div class="full-scorecard">';
        
        // Check if we have multiple innings to show tabs
        const hasMultipleInnings = fullScorecard.secondInnings && matchState.currentInnings > 1;
        
        if (hasMultipleInnings) {
            // Add tabs for multiple innings
            scorecardHTML += '<div class="scorecard-tabs">';
            scorecardHTML += '<button class="tab-btn active" onclick="switchScorecardTab(1)">First Innings</button>';
            scorecardHTML += '<button class="tab-btn" onclick="switchScorecardTab(2)">Second Innings</button>';
            scorecardHTML += '</div>';
        }
        
        // First Innings
        if (fullScorecard.firstInnings) {
            scorecardHTML += '<div class="innings-section" id="innings-1">';
            scorecardHTML += '<h3>First Innings</h3>';
            scorecardHTML += `<h4>${matchState.battingTeam.full_name} Batting</h4>`;
            scorecardHTML += '<div class="scorecard-table batting-table">';
            scorecardHTML += '<div class="scorecard-header">';
            scorecardHTML += '<div>Player</div><div>Dismissal</div><div>Runs (Balls)</div><div>SR</div><div>4s/6s</div>';
            scorecardHTML += '</div>';
            
            // First show players in batting order who have batted
            matchState.firstInningsBattingOrderPlayers.forEach(player => {
                const battingScore = fullScorecard.firstInnings.batting.find(bs => bs.playerName === player.name);
                if (!battingScore || battingScore.ballsFaced === 0) return; // Skip if not batted yet
                
                const row = battingScore.getScorecardRow();
                const isCurrentlyBatting = player.id === matchState.striker?.id || player.id === matchState.nonStriker?.id;
                const rowClass = isCurrentlyBatting ? 'scorecard-row current-batsman' : 'scorecard-row';
                
                scorecardHTML += `<div class="${rowClass}">`;
                scorecardHTML += `<div>${player.name}${player.is_captain ? ' (c)' : ''}${player.is_wicketkeeper ? ' (wk)' : ''}</div>`;
                scorecardHTML += `<div>${row.dismissal || row.bowled}</div>`;
                scorecardHTML += `<div>${row.score}</div>`;
                scorecardHTML += `<div>${row.strikeRate}</div>`;
                scorecardHTML += `<div>${row.fours}/${row.sixes}</div>`;
                scorecardHTML += '</div>';
            });
            
            // Then show remaining players in first innings team who haven't batted yet
            // Use the stored first innings batting team
            const firstInningsTeam = matchState.firstInningsBattingTeam;
            firstInningsTeam.players.forEach(player => {
                const hasBatted = fullScorecard.firstInnings.batting.some(bs => 
                    bs.playerName === player.name && bs.ballsFaced > 0
                );
                if (hasBatted) return; // Skip if already shown
                
                scorecardHTML += '<div class="scorecard-row not-batted">';
                scorecardHTML += `<div>${player.name}${player.is_captain ? ' (c)' : ''}${player.is_wicketkeeper ? ' (wk)' : ''}</div>`;
                scorecardHTML += `<div>-</div>`;
                scorecardHTML += `<div>-</div>`;
                scorecardHTML += `<div>-</div>`;
                scorecardHTML += `<div>-</div>`;
                scorecardHTML += '</div>';
            });
            
            // Add Extras row
            const firstInningsExtras = fullScorecard.firstInnings.batting.reduce((total, battingScore) => {
                return total + (battingScore.extras || 0);
            }, 0);
            scorecardHTML += '<div class="scorecard-row extras-row">';
            scorecardHTML += '<div><strong>Extras</strong></div>';
            scorecardHTML += '<div></div>';
            scorecardHTML += `<div><strong>${firstInningsExtras}</strong></div>`;
            scorecardHTML += '<div></div>';
            scorecardHTML += '<div></div>';
            scorecardHTML += '</div>';
            
            // Add Total row
            const firstInningsTotal = fullScorecard.firstInnings.batting.reduce((total, battingScore) => {
                return total + battingScore.runsScored;
            }, 0);
            const firstInningsWickets = fullScorecard.firstInnings.batting.filter(battingScore => !battingScore.notOut).length;
            const firstInningsOvers = Math.floor(fullScorecard.firstInnings.batting.reduce((total, battingScore) => {
                return total + battingScore.ballsFaced;
            }, 0) / 6);
            const firstInningsBalls = fullScorecard.firstInnings.batting.reduce((total, battingScore) => {
                return total + battingScore.ballsFaced;
            }, 0) % 6;
            const oversFormatted = firstInningsBalls > 0 ? `${firstInningsOvers}.${firstInningsBalls}` : firstInningsOvers.toString();
            
            scorecardHTML += '<div class="scorecard-row total-row">';
            scorecardHTML += '<div><strong>TOTAL</strong></div>';
            scorecardHTML += '<div></div>';
            scorecardHTML += `<div><strong>${firstInningsTotal + firstInningsExtras}/${firstInningsWickets} (${oversFormatted})</strong></div>`;
            scorecardHTML += '<div></div>';
            scorecardHTML += '<div></div>';
            scorecardHTML += '</div>';
            
            scorecardHTML += '</div>';
            
            scorecardHTML += `<h4>${matchState.bowlingTeam.full_name} Bowling</h4>`;
            scorecardHTML += '<div class="scorecard-table bowling-table">';
            scorecardHTML += '<div class="scorecard-header">';
            scorecardHTML += '<div>Bowler</div><div>Overs</div><div>Runs</div><div>Wickets</div><div>Economy</div>';
            scorecardHTML += '</div>';
            
            // Only show bowlers who have actually bowled
            fullScorecard.firstInnings.bowling
                .filter(bowlingFigures => bowlingFigures.deliveries > 0)
                .forEach(bowlingFigures => {
                const row = bowlingFigures.getScorecardRow();
                scorecardHTML += '<div class="scorecard-row">';
                scorecardHTML += `<div>${row.playerName}</div>`;
                scorecardHTML += `<div>${row.overs}</div>`;
                scorecardHTML += `<div>${row.runs}</div>`;
                scorecardHTML += `<div>${row.wickets}</div>`;
                scorecardHTML += `<div>${row.economy}</div>`;
                scorecardHTML += '</div>';
            });
            scorecardHTML += '</div>';
            scorecardHTML += '</div>';
        }
        
        // Second Innings (if completed)
        if (fullScorecard.secondInnings && matchState.currentInnings > 1) {
            scorecardHTML += '<div class="innings-section" id="innings-2" style="display: none;">';
            scorecardHTML += '<h3>Second Innings</h3>';
            scorecardHTML += `<h4>${matchState.battingTeam.full_name} Batting</h4>`;
            scorecardHTML += '<div class="scorecard-table batting-table">';
            scorecardHTML += '<div class="scorecard-header">';
            scorecardHTML += '<div>Player</div><div>Dismissal</div><div>Runs (Balls)</div><div>SR</div><div>4s/6s</div>';
            scorecardHTML += '</div>';
            
            // First show players in batting order who have batted
            matchState.secondInningsBattingOrderPlayers.forEach(player => {
                const battingScore = fullScorecard.secondInnings.batting.find(bs => bs.playerName === player.name);
                if (!battingScore || battingScore.ballsFaced === 0) return; // Skip if not batted yet
                
                const row = battingScore.getScorecardRow();
                const isCurrentlyBatting = player.id === matchState.striker?.id || player.id === matchState.nonStriker?.id;
                const rowClass = isCurrentlyBatting ? 'scorecard-row current-batsman' : 'scorecard-row';
                
                scorecardHTML += `<div class="${rowClass}">`;
                scorecardHTML += `<div>${player.name}${player.is_captain ? ' (c)' : ''}${player.is_wicketkeeper ? ' (wk)' : ''}</div>`;
                scorecardHTML += `<div>${row.dismissal || row.bowled}</div>`;
                scorecardHTML += `<div>${row.score}</div>`;
                scorecardHTML += `<div>${row.strikeRate}</div>`;
                scorecardHTML += `<div>${row.fours}/${row.sixes}</div>`;
                scorecardHTML += '</div>';
            });
            
            // Then show remaining players in second innings team who haven't batted yet
            // We need to get the second innings team from the current match state
            const secondInningsTeam = matchState.battingTeam; // This is the current second innings batting team
            secondInningsTeam.players.forEach(player => {
                const hasBatted = fullScorecard.secondInnings.batting.some(bs => 
                    bs.playerName === player.name && bs.ballsFaced > 0
                );
                if (hasBatted) return; // Skip if already shown
                
                scorecardHTML += '<div class="scorecard-row not-batted">';
                scorecardHTML += `<div>${player.name}${player.is_captain ? ' (c)' : ''}${player.is_wicketkeeper ? ' (wk)' : ''}</div>`;
                scorecardHTML += `<div>-</div>`;
                scorecardHTML += `<div>-</div>`;
                scorecardHTML += `<div>-</div>`;
                scorecardHTML += `<div>-</div>`;
                scorecardHTML += '</div>';
            });
            
            // Add Extras row for second innings
            const secondInningsExtras = fullScorecard.secondInnings.batting.reduce((total, battingScore) => {
                return total + (battingScore.extras || 0);
            }, 0);
            scorecardHTML += '<div class="scorecard-row extras-row">';
            scorecardHTML += '<div><strong>Extras</strong></div>';
            scorecardHTML += '<div></div>';
            scorecardHTML += `<div><strong>${secondInningsExtras}</strong></div>`;
            scorecardHTML += '<div></div>';
            scorecardHTML += '<div></div>';
            scorecardHTML += '</div>';
            
            // Add Total row for second innings
            const secondInningsTotal = fullScorecard.secondInnings.batting.reduce((total, battingScore) => {
                return total + battingScore.runsScored;
            }, 0);
            const secondInningsWickets = fullScorecard.secondInnings.batting.filter(battingScore => !battingScore.notOut).length;
            const secondInningsOvers = Math.floor(fullScorecard.secondInnings.batting.reduce((total, battingScore) => {
                return total + battingScore.ballsFaced;
            }, 0) / 6);
            const secondInningsBalls = fullScorecard.secondInnings.batting.reduce((total, battingScore) => {
                return total + battingScore.ballsFaced;
            }, 0) % 6;
            const secondOversFormatted = secondInningsBalls > 0 ? `${secondInningsOvers}.${secondInningsBalls}` : secondInningsOvers.toString();
            
            scorecardHTML += '<div class="scorecard-row total-row">';
            scorecardHTML += '<div><strong>TOTAL</strong></div>';
            scorecardHTML += '<div></div>';
            scorecardHTML += `<div><strong>${secondInningsTotal + secondInningsExtras}/${secondInningsWickets} (${secondOversFormatted})</strong></div>`;
            scorecardHTML += '<div></div>';
            scorecardHTML += '<div></div>';
            scorecardHTML += '</div>';
            
            scorecardHTML += '</div>';
            
            scorecardHTML += `<h4>${matchState.bowlingTeam.full_name} Bowling</h4>`;
            scorecardHTML += '<div class="scorecard-table bowling-table">';
            scorecardHTML += '<div class="scorecard-header">';
            scorecardHTML += '<div>Bowler</div><div>Overs</div><div>Runs</div><div>Wickets</div><div>Economy</div>';
            scorecardHTML += '</div>';
            
            // Only show bowlers who have actually bowled
            fullScorecard.secondInnings.bowling
                .filter(bowlingFigures => bowlingFigures.deliveries > 0)
                .forEach(bowlingFigures => {
                const row = bowlingFigures.getScorecardRow();
                scorecardHTML += '<div class="scorecard-row">';
                scorecardHTML += `<div>${row.playerName}</div>`;
                scorecardHTML += `<div>${row.overs}</div>`;
                scorecardHTML += `<div>${row.runs}</div>`;
                scorecardHTML += `<div>${row.wickets}</div>`;
                scorecardHTML += `<div>${row.economy}</div>`;
                scorecardHTML += '</div>';
            });
            scorecardHTML += '</div>';
            scorecardHTML += '</div>';
        }
        
        scorecardHTML += '</div>';
        
        // Show in a modal
        const modal = document.getElementById('player-modal');
        const modalContent = modal.querySelector('.modal-content');
        
        // Create header with close button
        const headerHTML = `
            <div class="scorecard-header-container">
                <h2>üèè Full Match Scorecard</h2>
                <button class="btn btn-secondary close-btn" onclick="closeScorecard()">‚ùå</button>
            </div>
        `;
        
        modalContent.innerHTML = headerHTML + scorecardHTML;
        
        modal.style.display = 'block';
    }
    
    // Function to close the scorecard modal
    function closeScorecard() {
        const modal = document.getElementById('player-modal');
        modal.style.display = 'none';
        resetModalToOriginal();
    }
    
    // Function to switch between scorecard tabs
    function switchScorecardTab(inningsNumber) {
        // Hide all innings sections
        const firstInnings = document.getElementById('innings-1');
        const secondInnings = document.getElementById('innings-2');
        
        if (firstInnings) firstInnings.style.display = 'none';
        if (secondInnings) secondInnings.style.display = 'none';
        
        // Show selected innings
        if (inningsNumber === 1 && firstInnings) {
            firstInnings.style.display = 'block';
        } else if (inningsNumber === 2 && secondInnings) {
            secondInnings.style.display = 'block';
        }
        
        // Update tab button states
        const tabBtns = document.querySelectorAll('.tab-btn');
        tabBtns.forEach(btn => btn.classList.remove('active'));
        
        // Find and activate the clicked tab
        const clickedTab = Array.from(tabBtns).find(btn => 
            btn.textContent.toLowerCase().includes(inningsNumber === 1 ? 'first' : 'second')
        );
        if (clickedTab) {
            clickedTab.classList.add('active');
        }
    }
</script>
{% endblock %}